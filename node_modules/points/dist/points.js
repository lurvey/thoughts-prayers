(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Points"] = factory();
	else
		root["Points"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.scale = exports.rotate = exports.reverse = exports.remove = exports.position = exports.offset = exports.moveIndex = exports.length = exports.cubify = exports.boundingBox = exports.add = undefined;

	var _add = __webpack_require__(1);

	var _add2 = _interopRequireDefault(_add);

	var _boundingBox = __webpack_require__(5);

	var _boundingBox2 = _interopRequireDefault(_boundingBox);

	var _cubify = __webpack_require__(2);

	var _cubify2 = _interopRequireDefault(_cubify);

	var _length = __webpack_require__(7);

	var _length2 = _interopRequireDefault(_length);

	var _moveIndex = __webpack_require__(8);

	var _moveIndex2 = _interopRequireDefault(_moveIndex);

	var _offset = __webpack_require__(9);

	var _offset2 = _interopRequireDefault(_offset);

	var _position = __webpack_require__(10);

	var _position2 = _interopRequireDefault(_position);

	var _remove = __webpack_require__(11);

	var _remove2 = _interopRequireDefault(_remove);

	var _reverse = __webpack_require__(12);

	var _reverse2 = _interopRequireDefault(_reverse);

	var _rotate = __webpack_require__(13);

	var _rotate2 = _interopRequireDefault(_rotate);

	var _scale = __webpack_require__(14);

	var _scale2 = _interopRequireDefault(_scale);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.add = _add2.default;
	exports.boundingBox = _boundingBox2.default;
	exports.cubify = _cubify2.default;
	exports.length = _length2.default;
	exports.moveIndex = _moveIndex2.default;
	exports.offset = _offset2.default;
	exports.position = _position2.default;
	exports.remove = _remove2.default;
	exports.reverse = _reverse2.default;
	exports.rotate = _rotate2.default;
	exports.scale = _scale2.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.curvePoints = undefined;

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _cubify = __webpack_require__(2);

	var _cubify2 = _interopRequireDefault(_cubify);

	var _helpers = __webpack_require__(4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var basicPoints = function basicPoints(a, b) {
	  return [{
	    x: (0, _helpers.numberAtInterval)(a.x, b.x, 0.5),
	    y: (0, _helpers.numberAtInterval)(a.y, b.y, 0.5)
	  }, b];
	};

	var curvePoints = function curvePoints(a, b) {
	  var _b$curve = b.curve;
	  var x1 = _b$curve.x1;
	  var y1 = _b$curve.y1;
	  var x2 = _b$curve.x2;
	  var y2 = _b$curve.y2;


	  var A = { x: a.x, y: a.y };
	  var B = { x: x1, y: y1 };
	  var C = { x: x2, y: y2 };
	  var D = { x: b.x, y: b.y };
	  var E = { x: (0, _helpers.numberAtInterval)(A.x, B.x, 0.5), y: (0, _helpers.numberAtInterval)(A.y, B.y, 0.5) };
	  var F = { x: (0, _helpers.numberAtInterval)(B.x, C.x, 0.5), y: (0, _helpers.numberAtInterval)(B.y, C.y, 0.5) };
	  var G = { x: (0, _helpers.numberAtInterval)(C.x, D.x, 0.5), y: (0, _helpers.numberAtInterval)(C.y, D.y, 0.5) };
	  var H = { x: (0, _helpers.numberAtInterval)(E.x, F.x, 0.5), y: (0, _helpers.numberAtInterval)(E.y, F.y, 0.5) };
	  var J = { x: (0, _helpers.numberAtInterval)(F.x, G.x, 0.5), y: (0, _helpers.numberAtInterval)(F.y, G.y, 0.5) };
	  var K = { x: (0, _helpers.numberAtInterval)(H.x, J.x, 0.5), y: (0, _helpers.numberAtInterval)(H.y, J.y, 0.5) };

	  return [{ x: K.x, y: K.y, curve: { type: 'cubic', x1: E.x, y1: E.y, x2: H.x, y2: H.y } }, { x: D.x, y: D.y, curve: { type: 'cubic', x1: J.x, y1: J.y, x2: G.x, y2: G.y } }];
	};

	var points = function points(a, b) {
	  return b.curve ? curvePoints(a, b) : basicPoints(a, b);
	};

	var addPoints = function addPoints(shape, pointsRequired) {
	  var s = [].concat(_toConsumableArray(shape));

	  for (var i = 1; i < s.length; i += 2) {
	    if (s.length >= pointsRequired) {
	      return s;
	    }

	    var _points = points(s[i - 1], s[i]);

	    var _points2 = _slicedToArray(_points, 2);

	    var a = _points2[0];
	    var b = _points2[1];


	    s.splice(i, 1, a, b);
	  }

	  return addPoints(s, pointsRequired);
	};

	var add = function add(shape, pointsRequired) {
	  return addPoints((0, _cubify2.default)(shape), pointsRequired);
	};

	exports.curvePoints = curvePoints;
	exports.default = add;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _arcToBezier = __webpack_require__(3);

	var _arcToBezier2 = _interopRequireDefault(_arcToBezier);

	var _helpers = __webpack_require__(4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var cubifyShape = function cubifyShape(shape) {
	  var s = [];

	  for (var i = 0, l = shape.length; i < l; i++) {
	    var point = shape[i];

	    if (point.curve && point.curve.type !== 'cubic') {
	      var _shape = shape[i - 1];
	      var px = _shape.x;
	      var py = _shape.y;
	      var cx = point.x;
	      var cy = point.y;


	      if (point.curve.type === 'arc') {
	        var curves = (0, _arcToBezier2.default)({
	          px: px,
	          py: py,
	          cx: cx,
	          cy: cy,
	          rx: point.curve.rx,
	          ry: point.curve.ry,
	          xAxisRotation: point.curve.xAxisRotation,
	          largeArcFlag: point.curve.largeArcFlag,
	          sweepFlag: point.curve.sweepFlag
	        });

	        curves.forEach(function (_ref) {
	          var x1 = _ref.x1;
	          var y1 = _ref.y1;
	          var x2 = _ref.x2;
	          var y2 = _ref.y2;
	          var x = _ref.x;
	          var y = _ref.y;

	          s.push({ x: x, y: y, curve: { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 } });
	        });
	      } else if (point.curve.type === 'quadratic') {
	        var x1 = px + 2 / 3 * (point.curve.x1 - px);
	        var y1 = py + 2 / 3 * (point.curve.y1 - py);
	        var x2 = cx + 2 / 3 * (point.curve.x1 - cx);
	        var y2 = cy + 2 / 3 * (point.curve.y1 - cy);

	        s.push({ x: cx, y: cy, curve: { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 } });
	      }
	    } else {
	      s.push(point);
	    }
	  }

	  return s;
	};

	var cubify = function cubify(s) {
	  return (0, _helpers.applyFuncToShapes)(cubifyShape, s);
	};

	exports.default = cubify;

/***/ },
/* 3 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	// I extracted this from the a2c function from
	// SVG path – https://github.com/fontello/svgpath
	//
	// All credit goes to:
	//
	// Sergey Batishchev – https://github.com/snb2013
	// Vitaly Puzrin – https://github.com/puzrin
	// Alex Kocharin – https://github.com/rlidwka

	var TAU = Math.PI * 2;

	var mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
	  var x = _ref.x;
	  var y = _ref.y;

	  x *= rx;
	  y *= ry;

	  var xp = cosphi * x - sinphi * y;
	  var yp = sinphi * x + cosphi * y;

	  return {
	    x: xp + centerx,
	    y: yp + centery
	  };
	};

	var approxUnitArc = function approxUnitArc(ang1, ang2) {
	  var a = 4 / 3 * Math.tan(ang2 / 4);

	  var x1 = Math.cos(ang1);
	  var y1 = Math.sin(ang1);
	  var x2 = Math.cos(ang1 + ang2);
	  var y2 = Math.sin(ang1 + ang2);

	  return [{
	    x: x1 - y1 * a,
	    y: y1 + x1 * a
	  }, {
	    x: x2 + y2 * a,
	    y: y2 - x2 * a
	  }, {
	    x: x2,
	    y: y2
	  }];
	};

	var vectorAngle = function vectorAngle(ux, uy, vx, vy) {
	  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
	  var umag = Math.sqrt(ux * ux + uy * uy);
	  var vmag = Math.sqrt(ux * ux + uy * uy);
	  var dot = ux * vx + uy * vy;

	  var div = dot / (umag * vmag);

	  if (div > 1) {
	    div = 1;
	  }

	  if (div < -1) {
	    div = -1;
	  }

	  return sign * Math.acos(div);
	};

	var getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
	  var rxsq = Math.pow(rx, 2);
	  var rysq = Math.pow(ry, 2);
	  var pxpsq = Math.pow(pxp, 2);
	  var pypsq = Math.pow(pyp, 2);

	  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;

	  if (radicant < 0) {
	    radicant = 0;
	  }

	  radicant /= rxsq * pypsq + rysq * pxpsq;
	  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);

	  var centerxp = radicant * rx / ry * pyp;
	  var centeryp = radicant * -ry / rx * pxp;

	  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
	  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;

	  var vx1 = (pxp - centerxp) / rx;
	  var vy1 = (pyp - centeryp) / ry;
	  var vx2 = (-pxp - centerxp) / rx;
	  var vy2 = (-pyp - centeryp) / ry;

	  var ang1 = vectorAngle(1, 0, vx1, vy1);
	  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);

	  if (sweepFlag === 0 && ang2 > 0) {
	    ang2 -= TAU;
	  }

	  if (sweepFlag === 1 && ang2 < 0) {
	    ang2 += TAU;
	  }

	  return [centerx, centery, ang1, ang2];
	};

	var arcToBezier = function arcToBezier(_ref2) {
	  var px = _ref2.px;
	  var py = _ref2.py;
	  var cx = _ref2.cx;
	  var cy = _ref2.cy;
	  var rx = _ref2.rx;
	  var ry = _ref2.ry;
	  var _ref2$xAxisRotation = _ref2.xAxisRotation;
	  var xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation;
	  var _ref2$largeArcFlag = _ref2.largeArcFlag;
	  var largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag;
	  var _ref2$sweepFlag = _ref2.sweepFlag;
	  var sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;

	  var curves = [];

	  if (rx === 0 || ry === 0) {
	    return [];
	  }

	  var sinphi = Math.sin(xAxisRotation * TAU / 360);
	  var cosphi = Math.cos(xAxisRotation * TAU / 360);

	  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
	  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;

	  if (pxp === 0 && pyp === 0) {
	    return [];
	  }

	  rx = Math.abs(rx);
	  ry = Math.abs(ry);

	  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);

	  if (lambda > 1) {
	    rx *= Math.sqrt(lambda);
	    ry *= Math.sqrt(lambda);
	  }

	  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp);

	  var _getArcCenter2 = _slicedToArray(_getArcCenter, 4);

	  var centerx = _getArcCenter2[0];
	  var centery = _getArcCenter2[1];
	  var ang1 = _getArcCenter2[2];
	  var ang2 = _getArcCenter2[3];


	  var segments = Math.max(Math.ceil(Math.abs(ang2) / (TAU / 4)), 1);

	  ang2 /= segments;

	  for (var i = 0; i < segments; i++) {
	    curves.push(approxUnitArc(ang1, ang2));
	    ang1 += ang2;
	  }

	  return curves.map(function (curve) {
	    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery);

	    var x1 = _mapToEllipse.x;
	    var y1 = _mapToEllipse.y;

	    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery);

	    var x2 = _mapToEllipse2.x;
	    var y2 = _mapToEllipse2.y;

	    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery);

	    var x = _mapToEllipse3.x;
	    var y = _mapToEllipse3.y;


	    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };
	  });
	};

	exports.default = arcToBezier;

/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var angleFromSides = function angleFromSides(a, b, c) {
	  var r = Math.acos((Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) / (2 * a * b));

	  return r * (180 / Math.PI);
	};

	var applyFuncToShapes = function applyFuncToShapes(f, s) {
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }

	  if (isShapeArray(s)) {
	    return s.map(function (shape) {
	      return f.apply(undefined, [shape].concat(args));
	    });
	  }

	  return f.apply(undefined, [s].concat(args));
	};

	var getShapeArray = function getShapeArray(s) {
	  return isShapeArray(s) ? s : [s];
	};

	var isShapeArray = function isShapeArray(s) {
	  return Array.isArray(s[0]);
	};

	var numberAtInterval = function numberAtInterval(a, b, interval) {
	  var c = a === b ? 0 : Math.abs(b - a);
	  return c === 0 ? a : a < b ? a + c * interval : a - c * interval;
	};

	exports.angleFromSides = angleFromSides;
	exports.applyFuncToShapes = applyFuncToShapes;
	exports.getShapeArray = getShapeArray;
	exports.isShapeArray = isShapeArray;
	exports.numberAtInterval = numberAtInterval;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _decurve = __webpack_require__(6);

	var _decurve2 = _interopRequireDefault(_decurve);

	var _helpers = __webpack_require__(4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var boundingBox = function boundingBox(s) {
	  var bottom = void 0;
	  var left = void 0;
	  var right = void 0;
	  var top = void 0;

	  var shapes = (0, _helpers.getShapeArray)(s);

	  shapes.map(function (shape) {
	    return (0, _decurve2.default)(shape).map(function (_ref) {
	      var x = _ref.x;
	      var y = _ref.y;

	      if (typeof bottom !== 'number' || y > bottom) {
	        bottom = y;
	      }

	      if (typeof left !== 'number' || x < left) {
	        left = x;
	      }

	      if (typeof right !== 'number' || x > right) {
	        right = x;
	      }

	      if (typeof top !== 'number' || y < top) {
	        top = y;
	      }
	    });
	  });

	  return {
	    bottom: bottom,
	    center: {
	      x: left + (right - left) / 2,
	      y: top + (bottom - top) / 2
	    },
	    left: left,
	    right: right,
	    top: top
	  };
	};

	exports.default = boundingBox;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _helpers = __webpack_require__(4);

	var _cubify = __webpack_require__(2);

	var _cubify2 = _interopRequireDefault(_cubify);

	var _add = __webpack_require__(1);

	var _length = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var angle = function angle(triangle) {
	  var _triangle$ = _slicedToArray(triangle[0], 2);

	  var ax = _triangle$[0];
	  var ay = _triangle$[1];

	  var _triangle$2 = _slicedToArray(triangle[1], 2);

	  var bx = _triangle$2[0];
	  var by = _triangle$2[1];

	  var _triangle$3 = _slicedToArray(triangle[2], 2);

	  var cx = _triangle$3[0];
	  var cy = _triangle$3[1];


	  var a = (0, _length.linearLength)(ax, ay, bx, by);
	  var b = (0, _length.linearLength)(bx, by, cx, cy);
	  var c = (0, _length.linearLength)(cx, cy, ax, ay);

	  return (0, _helpers.angleFromSides)(a, b, c);
	};

	var curved = function curved(shape) {
	  return shape.reduce(function (c, _ref) {
	    var curve = _ref.curve;
	    return curve ? true : c;
	  }, false);
	};

	var decurve = function decurve(shape) {
	  var accuracy = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

	  if (!curved(shape)) {
	    return shape;
	  }

	  var s = (0, _cubify2.default)(shape);
	  var d = [];

	  s.map(function (point, i) {
	    if (point.curve) {
	      var prevPoint = s[i - 1];
	      straighten(prevPoint, point, accuracy).map(function (p) {
	        return d.push(p);
	      });
	    } else {
	      d.push(point);
	    }
	  });

	  return d;
	};

	var straight = function straight(x1, y1, cx1, cy1, x2, y2, cx2, cy2, accuracy) {
	  var t1 = [[cx1, cy1], [x2, y2], [x1, y1]];
	  var t2 = [[cx2, cy2], [x1, y1], [x2, y2]];
	  return angle(t1) < accuracy && angle(t2) < accuracy;
	};

	var straighten = function straighten(prevPoint, point, accuracy) {
	  var x1 = prevPoint.x;
	  var y1 = prevPoint.y;
	  var x2 = point.x;
	  var y2 = point.y;
	  var curve = point.curve;
	  var cx1 = curve.x1;
	  var cy1 = curve.y1;
	  var cx2 = curve.x2;
	  var cy2 = curve.y2;


	  if (straight(x1, y1, cx1, cy1, x2, y2, cx2, cy2, accuracy)) {
	    return [point];
	  }

	  var _curvePoints = (0, _add.curvePoints)(prevPoint, point);

	  var _curvePoints2 = _slicedToArray(_curvePoints, 2);

	  var midPoint = _curvePoints2[0];
	  var lastPoint = _curvePoints2[1];


	  return [].concat(_toConsumableArray(straighten(prevPoint, midPoint, accuracy)), _toConsumableArray(straighten(midPoint, lastPoint, accuracy)));
	};

	exports.default = decurve;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.linearLength = undefined;

	var _decurve = __webpack_require__(6);

	var _decurve2 = _interopRequireDefault(_decurve);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var length = function length(shape, accuracy) {
	  var s = (0, _decurve2.default)(shape, accuracy);

	  return s.reduce(function (currentLength, _ref, i) {
	    var x2 = _ref.x;
	    var y2 = _ref.y;
	    var moveTo = _ref.moveTo;

	    if (!moveTo) {
	      var _s = s[i - 1];
	      var x1 = _s.x;
	      var y1 = _s.y;

	      currentLength += linearLength(x1, y1, x2, y2);
	    }

	    return currentLength;
	  }, 0);
	};

	var linearLength = function linearLength(x1, y1, x2, y2) {
	  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
	};

	exports.linearLength = linearLength;
	exports.default = length;

/***/ },
/* 8 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var moveIndex = function moveIndex(shape, offset) {
	  var k = shape.length - 1;
	  var c = shape[0];
	  var l = shape[k];
	  var o = (offset % k + k) % k;

	  if (c.x === l.x && c.y === l.y) {
	    return [{ x: shape[o].x, y: shape[o].y, moveTo: true }].concat(_toConsumableArray(shape.splice(o + 1)), _toConsumableArray(shape.splice(1, o)));
	  }

	  return shape;
	};

	exports.default = moveIndex;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _helpers = __webpack_require__(4);

	var offsetPoints = function offsetPoints(shape, x, y) {
	  return shape.map(function (point) {
	    var p = _extends({}, point);

	    p.x += x;
	    p.y += y;

	    if (p.curve) {
	      p.curve = _extends({}, p.curve);

	      if (p.curve.type === 'quadratic' || p.curve.type === 'cubic') {
	        p.curve.x1 += x;
	        p.curve.y1 += y;
	      }

	      if (p.curve.type === 'cubic') {
	        p.curve.x2 += x;
	        p.curve.y2 += y;
	      }
	    }

	    return p;
	  });
	};

	var offset = function offset(s) {
	  var x = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	  var y = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	  return (0, _helpers.applyFuncToShapes)(offsetPoints, s, x, y);
	};

	exports.default = offset;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _decurve = __webpack_require__(6);

	var _decurve2 = _interopRequireDefault(_decurve);

	var _length = __webpack_require__(7);

	var _length2 = _interopRequireDefault(_length);

	var _helpers = __webpack_require__(4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var angle = function angle(x1, y1, x2, y2, a) {
	  if (x1 === x2) {
	    return y1 >= y2 ? 0 : 180;
	  }

	  var b = 100;
	  var c = (0, _length.linearLength)(x2, y2, x1, y1 - b);
	  var ang = (0, _helpers.angleFromSides)(a, b, c);

	  return x1 < x2 ? ang : 360 - ang;
	};

	var over = function over(shape, length, totalLength, desiredLength) {
	  var _shape = shape[length - 2];
	  var x1 = _shape.x;
	  var y1 = _shape.y;
	  var _shape2 = shape[length - 1];
	  var x2 = _shape2.x;
	  var y2 = _shape2.y;

	  var segmentLength = (0, _length.linearLength)(x1, y1, x2, y2);
	  var segmentInterval = (desiredLength - totalLength) / segmentLength + 1;
	  return { x1: x1, y1: y1, x2: x2, y2: y2, segmentInterval: segmentInterval, segmentLength: segmentLength };
	};

	var position = function position(shape, interval, accuracy) {
	  var s = (0, _decurve2.default)(shape, accuracy);
	  var l = s.length;
	  var t = (0, _length2.default)(s);
	  var d = t * interval;

	  var _ref = interval > 1 ? over(s, l, t, d) : interval < 0 ? under(s, d) : within(s, l, d);

	  var x1 = _ref.x1;
	  var y1 = _ref.y1;
	  var x2 = _ref.x2;
	  var y2 = _ref.y2;
	  var segmentInterval = _ref.segmentInterval;
	  var segmentLength = _ref.segmentLength;


	  return {
	    angle: angle(x1, y1, x2, y2, segmentLength),
	    x: (0, _helpers.numberAtInterval)(x1, x2, segmentInterval),
	    y: (0, _helpers.numberAtInterval)(y1, y2, segmentInterval)
	  };
	};

	var under = function under(shape, desiredLength) {
	  var _shape$ = shape[0];
	  var x1 = _shape$.x;
	  var y1 = _shape$.y;
	  var _shape$2 = shape[1];
	  var x2 = _shape$2.x;
	  var y2 = _shape$2.y;

	  var segmentLength = (0, _length.linearLength)(x1, y1, x2, y2);
	  var segmentInterval = desiredLength / segmentLength;
	  return { x1: x1, y1: y1, x2: x2, y2: y2, segmentInterval: segmentInterval, segmentLength: segmentLength };
	};

	var within = function within(shape, length, desiredLength) {
	  var currentLength = 0;

	  for (var i = 0; i < length; i++) {
	    var moveTo = shape[i].moveTo;


	    if (!moveTo) {
	      var _shape3 = shape[i - 1];
	      var x1 = _shape3.x;
	      var y1 = _shape3.y;
	      var _shape$i = shape[i];
	      var x2 = _shape$i.x;
	      var y2 = _shape$i.y;


	      var segmentLength = (0, _length.linearLength)(x1, y1, x2, y2);

	      if (currentLength + segmentLength >= desiredLength) {
	        var segmentInterval = (desiredLength - currentLength) / segmentLength;
	        return { x1: x1, y1: y1, x2: x2, y2: y2, segmentInterval: segmentInterval, segmentLength: segmentLength };
	      }

	      currentLength += segmentLength;
	    }
	  }
	};

	exports.default = position;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _helpers = __webpack_require__(4);

	var isBetween = function isBetween(a, b, c) {
	  if (b.curve || c.curve) {
	    return false;
	  }

	  var crossProduct = (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y);

	  if (Math.abs(crossProduct) > Number.EPSILON) {
	    return false;
	  }

	  var dotProduct = (c.x - a.x) * (b.x - a.x) + (c.y - a.y) * (b.y - a.y);

	  if (dotProduct < 0) {
	    return false;
	  }

	  var squaredLengthBA = (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);

	  if (dotProduct > squaredLengthBA) {
	    return false;
	  }

	  return true;
	};

	var removePoints = function removePoints(shape) {
	  var s = [];

	  for (var i = 0, l = shape.length; i < l; i++) {
	    var a = s[s.length - 1];
	    var b = shape[i + 1];
	    var c = shape[i];

	    if (!(a && b && c) || !isBetween(a, b, c)) {
	      s.push(c);
	    }
	  }

	  return s;
	};

	var remove = function remove(s) {
	  return (0, _helpers.applyFuncToShapes)(removePoints, s);
	};

	exports.default = remove;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _cubify = __webpack_require__(2);

	var _cubify2 = _interopRequireDefault(_cubify);

	var _helpers = __webpack_require__(4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var reversePoints = function reversePoints(shape) {
	  var c = void 0;

	  return shape.reverse().map(function (_ref) {
	    var x = _ref.x;
	    var y = _ref.y;
	    var curve = _ref.curve;

	    var point = { x: x, y: y };

	    if (c) {
	      var _c = c;
	      var x2 = _c.x1;
	      var y2 = _c.y1;
	      var x1 = _c.x2;
	      var y1 = _c.y2;

	      point.curve = { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 };
	    }

	    c = curve ? curve : null;

	    return point;
	  });
	};

	var reverse = function reverse(s) {
	  return (0, _helpers.applyFuncToShapes)(reversePoints, (0, _cubify2.default)(s));
	};

	exports.default = reverse;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _helpers = __webpack_require__(4);

	var _boundingBox2 = __webpack_require__(5);

	var _boundingBox3 = _interopRequireDefault(_boundingBox2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var rotatePoint = function rotatePoint(x, y, c, s, about) {
	  var offsetX = about.x;
	  var offsetY = about.y;

	  var relativeX = x - offsetX;
	  var relativeY = y - offsetY;

	  return [relativeX * c - relativeY * s + offsetX, relativeX * s + relativeY * c + offsetY];
	};

	var rotatePoints = function rotatePoints(shape, angle, about) {
	  return shape.map(function (point) {
	    var r = angle * Math.PI / 180;
	    var c = Math.cos(r);
	    var s = Math.sin(r);

	    var _rotatePoint = rotatePoint(point.x, point.y, c, s, about);

	    var _rotatePoint2 = _slicedToArray(_rotatePoint, 2);

	    var x = _rotatePoint2[0];
	    var y = _rotatePoint2[1];

	    var p = _extends({}, point, { x: x, y: y });

	    if (p.curve) {
	      if (p.curve.type === 'quadratic' || p.curve.type === 'cubic') {
	        var _rotatePoint3 = rotatePoint(p.curve.x1, p.curve.y1, c, s, about);

	        var _rotatePoint4 = _slicedToArray(_rotatePoint3, 2);

	        var x1 = _rotatePoint4[0];
	        var y1 = _rotatePoint4[1];

	        p.curve = _extends({}, p.curve, { x1: x1, y1: y1 });
	      }

	      if (p.curve.type === 'cubic') {
	        var _rotatePoint5 = rotatePoint(p.curve.x2, p.curve.y2, c, s, about);

	        var _rotatePoint6 = _slicedToArray(_rotatePoint5, 2);

	        var x2 = _rotatePoint6[0];
	        var y2 = _rotatePoint6[1];

	        p.curve = _extends({}, p.curve, { x2: x2, y2: y2 });
	      }
	    }

	    return p;
	  });
	};

	var rotate = function rotate(s, angle) {
	  var _boundingBox = (0, _boundingBox3.default)(s);

	  var about = _boundingBox.center;

	  return (0, _helpers.applyFuncToShapes)(rotatePoints, s, angle, about);
	};

	exports.default = rotate;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _boundingBox2 = __webpack_require__(5);

	var _boundingBox3 = _interopRequireDefault(_boundingBox2);

	var _helpers = __webpack_require__(4);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var scalePoint = function scalePoint(point, scaleFactor, anchorX, anchorY) {
	  var p = _extends({}, point);

	  p.x = anchorX - (anchorX - p.x) * scaleFactor;
	  p.y = anchorY - (anchorY - p.y) * scaleFactor;

	  if (point.curve) {
	    p.curve = _extends({}, p.curve);

	    if (p.curve.type === 'arc') {
	      if (p.curve.rx) {
	        p.curve.rx = p.curve.rx * scaleFactor;
	      }

	      if (p.curve.ry) {
	        p.curve.ry = p.curve.ry * scaleFactor;
	      }
	    } else {
	      p.curve.x1 = anchorX - (anchorX - p.curve.x1) * scaleFactor;
	      p.curve.y1 = anchorY - (anchorY - p.curve.y1) * scaleFactor;

	      if (p.curve.type === 'cubic') {
	        p.curve.x2 = anchorX - (anchorX - p.curve.x2) * scaleFactor;
	        p.curve.y2 = anchorY - (anchorY - p.curve.y2) * scaleFactor;
	      }
	    }
	  }

	  return p;
	};

	var scale = function scale(s, scaleFactor) {
	  var anchor = arguments.length <= 2 || arguments[2] === undefined ? 'center' : arguments[2];

	  var _boundingBox = (0, _boundingBox3.default)(s);

	  var bottom = _boundingBox.bottom;
	  var center = _boundingBox.center;
	  var left = _boundingBox.left;
	  var right = _boundingBox.right;
	  var top = _boundingBox.top;


	  var anchorX = center.x;
	  var anchorY = center.y;

	  switch (anchor) {
	    case 'topLeft':
	      anchorX = left;
	      anchorY = top;
	      break;
	    case 'topRight':
	      anchorX = right;
	      anchorY = top;
	      break;
	    case 'bottomRight':
	      anchorX = right;
	      anchorY = bottom;
	      break;
	    case 'bottomLeft':
	      anchorX = left;
	      anchorY = bottom;
	      break;
	  }

	  return (0, _helpers.applyFuncToShapes)(function (shape) {
	    return shape.map(function (point) {
	      return scalePoint(point, scaleFactor, anchorX, anchorY);
	    });
	  }, s);
	};

	exports.default = scale;

/***/ }
/******/ ])
});
;