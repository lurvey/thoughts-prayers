'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.curvePoints = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _cubify = require('./cubify');

var _cubify2 = _interopRequireDefault(_cubify);

var _helpers = require('./helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var basicPoints = function basicPoints(a, b) {
  return [{
    x: (0, _helpers.numberAtInterval)(a.x, b.x, 0.5),
    y: (0, _helpers.numberAtInterval)(a.y, b.y, 0.5)
  }, b];
};

var curvePoints = function curvePoints(a, b) {
  var _b$curve = b.curve;
  var x1 = _b$curve.x1;
  var y1 = _b$curve.y1;
  var x2 = _b$curve.x2;
  var y2 = _b$curve.y2;


  var A = { x: a.x, y: a.y };
  var B = { x: x1, y: y1 };
  var C = { x: x2, y: y2 };
  var D = { x: b.x, y: b.y };
  var E = { x: (0, _helpers.numberAtInterval)(A.x, B.x, 0.5), y: (0, _helpers.numberAtInterval)(A.y, B.y, 0.5) };
  var F = { x: (0, _helpers.numberAtInterval)(B.x, C.x, 0.5), y: (0, _helpers.numberAtInterval)(B.y, C.y, 0.5) };
  var G = { x: (0, _helpers.numberAtInterval)(C.x, D.x, 0.5), y: (0, _helpers.numberAtInterval)(C.y, D.y, 0.5) };
  var H = { x: (0, _helpers.numberAtInterval)(E.x, F.x, 0.5), y: (0, _helpers.numberAtInterval)(E.y, F.y, 0.5) };
  var J = { x: (0, _helpers.numberAtInterval)(F.x, G.x, 0.5), y: (0, _helpers.numberAtInterval)(F.y, G.y, 0.5) };
  var K = { x: (0, _helpers.numberAtInterval)(H.x, J.x, 0.5), y: (0, _helpers.numberAtInterval)(H.y, J.y, 0.5) };

  return [{ x: K.x, y: K.y, curve: { type: 'cubic', x1: E.x, y1: E.y, x2: H.x, y2: H.y } }, { x: D.x, y: D.y, curve: { type: 'cubic', x1: J.x, y1: J.y, x2: G.x, y2: G.y } }];
};

var points = function points(a, b) {
  return b.curve ? curvePoints(a, b) : basicPoints(a, b);
};

var addPoints = function addPoints(shape, pointsRequired) {
  var s = [].concat(_toConsumableArray(shape));

  for (var i = 1; i < s.length; i += 2) {
    if (s.length >= pointsRequired) {
      return s;
    }

    var _points = points(s[i - 1], s[i]);

    var _points2 = _slicedToArray(_points, 2);

    var a = _points2[0];
    var b = _points2[1];


    s.splice(i, 1, a, b);
  }

  return addPoints(s, pointsRequired);
};

var add = function add(shape, pointsRequired) {
  return addPoints((0, _cubify2.default)(shape), pointsRequired);
};

exports.curvePoints = curvePoints;
exports.default = add;