'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _arcToBezier = require('./arcToBezier');

var _arcToBezier2 = _interopRequireDefault(_arcToBezier);

var _helpers = require('./helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cubifyShape = function cubifyShape(shape) {
  var s = [];

  for (var i = 0, l = shape.length; i < l; i++) {
    var point = shape[i];

    if (point.curve && point.curve.type !== 'cubic') {
      var _shape = shape[i - 1];
      var px = _shape.x;
      var py = _shape.y;
      var cx = point.x;
      var cy = point.y;


      if (point.curve.type === 'arc') {
        var curves = (0, _arcToBezier2.default)({
          px: px,
          py: py,
          cx: cx,
          cy: cy,
          rx: point.curve.rx,
          ry: point.curve.ry,
          xAxisRotation: point.curve.xAxisRotation,
          largeArcFlag: point.curve.largeArcFlag,
          sweepFlag: point.curve.sweepFlag
        });

        curves.forEach(function (_ref) {
          var x1 = _ref.x1;
          var y1 = _ref.y1;
          var x2 = _ref.x2;
          var y2 = _ref.y2;
          var x = _ref.x;
          var y = _ref.y;

          s.push({ x: x, y: y, curve: { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 } });
        });
      } else if (point.curve.type === 'quadratic') {
        var x1 = px + 2 / 3 * (point.curve.x1 - px);
        var y1 = py + 2 / 3 * (point.curve.y1 - py);
        var x2 = cx + 2 / 3 * (point.curve.x1 - cx);
        var y2 = cy + 2 / 3 * (point.curve.y1 - cy);

        s.push({ x: cx, y: cy, curve: { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 } });
      }
    } else {
      s.push(point);
    }
  }

  return s;
};

var cubify = function cubify(s) {
  return (0, _helpers.applyFuncToShapes)(cubifyShape, s);
};

exports.default = cubify;