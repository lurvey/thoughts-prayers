(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Wilderness"] = factory();
	else
		root["Wilderness"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.timeline = exports.state = exports.shape = exports.render = exports.play = exports.pause = undefined;

	var _core = __webpack_require__(1);

	var _dom = __webpack_require__(36);

	exports.pause = _core.pause;
	exports.play = _dom.play;
	exports.render = _dom.render;
	exports.shape = _dom.shape;
	exports.state = _core.state;
	exports.timeline = _dom.timeline;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.tick = exports.state = exports.shape = exports.play = exports.pause = exports.create = undefined;

	var _pause = __webpack_require__(2);

	var _pause2 = _interopRequireDefault(_pause);

	var _play = __webpack_require__(27);

	var _play2 = _interopRequireDefault(_play);

	var _shape = __webpack_require__(28);

	var _shape2 = _interopRequireDefault(_shape);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.create = _shape.create;
	exports.pause = _pause2.default;
	exports.play = _play2.default;
	exports.shape = _shape2.default;
	exports.state = _shape.state;
	exports.tick = _play.tick;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _helpers = __webpack_require__(3);

	var pause = function pause(_ref) {
	  var state = _ref.state;
	  var animation = state.animation;


	  if (animation && !(0, _helpers.paused)(animation)) {
	    animation.pause = Date.now();
	  }
	};

	exports.default = pause;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.tween = exports.previousIteration = exports.paused = exports.normalise = exports.match = exports.iterationsComplete = exports.finished = exports.filter = exports.easingFunc = exports.currentReverse = exports.currentState = exports.currentIteration = undefined;

	var _animation = __webpack_require__(4);

	var _misc = __webpack_require__(6);

	var _match = __webpack_require__(7);

	var _match2 = _interopRequireDefault(_match);

	var _points = __webpack_require__(8);

	var _points2 = _interopRequireDefault(_points);

	var _tween = __webpack_require__(24);

	var _tween2 = _interopRequireDefault(_tween);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.currentIteration = _animation.currentIteration;
	exports.currentState = _animation.currentState;
	exports.currentReverse = _animation.currentReverse;
	exports.easingFunc = _animation.easingFunc;
	exports.filter = _misc.filter;
	exports.finished = _animation.finished;
	exports.iterationsComplete = _animation.iterationsComplete;
	exports.match = _match2.default;
	exports.normalise = _points2.default;
	exports.paused = _animation.paused;
	exports.previousIteration = _animation.previousIteration;
	exports.tween = _tween2.default;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.previousIteration = exports.paused = exports.iterationsComplete = exports.finished = exports.easingFunc = exports.currentReverse = exports.currentState = exports.currentIteration = undefined;

	var _tweenFunctions = __webpack_require__(5);

	var _tweenFunctions2 = _interopRequireDefault(_tweenFunctions);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var currentIteration = function currentIteration(totalIterations) {
	  return Math.max(1, Math.ceil(totalIterations));
	};

	var currentState = function currentState() {
	  var animation = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var _animation$alternate = animation.alternate;
	  var alternate = _animation$alternate === undefined ? false : _animation$alternate;
	  var _animation$initialPro = animation.initialProgress;
	  var initialProgress = _animation$initialPro === undefined ? 0 : _animation$initialPro;
	  var _animation$reverse = animation.reverse;
	  var reverse = _animation$reverse === undefined ? false : _animation$reverse;
	  var _animation$started = animation.started;
	  var started = _animation$started === undefined ? false : _animation$started;


	  var iterations = started ? iterationsComplete(animation) : 0;
	  var totalIterations = iterations + initialProgress;
	  var i = currentIteration(totalIterations);
	  var r = currentReverse(alternate, i, reverse);
	  var progress = totalIterations - previousIteration(totalIterations);

	  return {
	    currentProgress: r ? 1 - progress : progress,
	    currentReverse: r,
	    iterationsComplete: iterations
	  };
	};

	var currentReverse = function currentReverse(alternate, iteration, reverse) {
	  return alternate ? iteration % 2 === 0 ? !reverse : reverse : reverse;
	};

	var easingFunc = function easingFunc(easing, defaultEasing) {
	  var e = easing || defaultEasing;
	  return typeof e === 'function' ? e : _tweenFunctions2.default[e];
	};

	var finished = function finished(animation) {
	  return iterationsComplete(animation) >= animation.iterations;
	};

	var iterationsComplete = function iterationsComplete(_ref) {
	  var duration = _ref.duration;
	  var iterations = _ref.iterations;
	  var play = _ref.play;
	  var pause = _ref.pause;

	  var time = Math.max(0, pause ? pause - play : Date.now() - play);
	  return Math.min(iterations, time / duration);
	};

	var paused = function paused(_ref2) {
	  var pause = _ref2.pause;
	  return Boolean(pause);
	};

	var previousIteration = function previousIteration(totalIterations) {
	  return Math.max(0, totalIterations % 1 === 0 ? Math.floor(totalIterations - 0.1) : Math.floor(totalIterations));
	};

	exports.currentIteration = currentIteration;
	exports.currentState = currentState;
	exports.currentReverse = currentReverse;
	exports.easingFunc = easingFunc;
	exports.finished = finished;
	exports.iterationsComplete = iterationsComplete;
	exports.paused = paused;
	exports.previousIteration = previousIteration;

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';

	// t: current time, b: beginning value, _c: final value, d: total duration
	var tweenFunctions = {
	  linear: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * t / d + b;
	  },
	  easeInQuad: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t + b;
	  },
	  easeOutQuad: function(t, b, _c, d) {
	    var c = _c - b;
	    return -c * (t /= d) * (t - 2) + b;
	  },
	  easeInOutQuad: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t + b;
	    } else {
	      return -c / 2 * ((--t) * (t - 2) - 1) + b;
	    }
	  },
	  easeInCubic: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t * t + b;
	  },
	  easeOutCubic: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * ((t = t / d - 1) * t * t + 1) + b;
	  },
	  easeInOutCubic: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t * t + b;
	    } else {
	      return c / 2 * ((t -= 2) * t * t + 2) + b;
	    }
	  },
	  easeInQuart: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t * t * t + b;
	  },
	  easeOutQuart: function(t, b, _c, d) {
	    var c = _c - b;
	    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
	  },
	  easeInOutQuart: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t * t * t + b;
	    } else {
	      return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
	    }
	  },
	  easeInQuint: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * (t /= d) * t * t * t * t + b;
	  },
	  easeOutQuint: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
	  },
	  easeInOutQuint: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return c / 2 * t * t * t * t * t + b;
	    } else {
	      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
	    }
	  },
	  easeInSine: function(t, b, _c, d) {
	    var c = _c - b;
	    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
	  },
	  easeOutSine: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * Math.sin(t / d * (Math.PI / 2)) + b;
	  },
	  easeInOutSine: function(t, b, _c, d) {
	    var c = _c - b;
	    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
	  },
	  easeInExpo: function(t, b, _c, d) {
	    var c = _c - b;
	    return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	  },
	  easeOutExpo: function(t, b, _c, d) {
	    var c = _c - b;
	    return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	  },
	  easeInOutExpo: function(t, b, _c, d) {
	    var c = _c - b;
	    if (t === 0) {
	      return b;
	    }
	    if (t === d) {
	      return b + c;
	    }
	    if ((t /= d / 2) < 1) {
	      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
	    } else {
	      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
	    }
	  },
	  easeInCirc: function(t, b, _c, d) {
	    var c = _c - b;
	    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
	  },
	  easeOutCirc: function(t, b, _c, d) {
	    var c = _c - b;
	    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
	  },
	  easeInOutCirc: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d / 2) < 1) {
	      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
	    } else {
	      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
	    }
	  },
	  easeInElastic: function(t, b, _c, d) {
	    var c = _c - b;
	    var a, p, s;
	    s = 1.70158;
	    p = 0;
	    a = c;
	    if (t === 0) {
	      return b;
	    } else if ((t /= d) === 1) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * 0.3;
	    }
	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    } else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }
	    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	  },
	  easeOutElastic: function(t, b, _c, d) {
	    var c = _c - b;
	    var a, p, s;
	    s = 1.70158;
	    p = 0;
	    a = c;
	    if (t === 0) {
	      return b;
	    } else if ((t /= d) === 1) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * 0.3;
	    }
	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    } else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }
	    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
	  },
	  easeInOutElastic: function(t, b, _c, d) {
	    var c = _c - b;
	    var a, p, s;
	    s = 1.70158;
	    p = 0;
	    a = c;
	    if (t === 0) {
	      return b;
	    } else if ((t /= d / 2) === 2) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * (0.3 * 1.5);
	    }
	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    } else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }
	    if (t < 1) {
	      return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	    } else {
	      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
	    }
	  },
	  easeInBack: function(t, b, _c, d, s) {
	    var c = _c - b;
	    if (s === void 0) {
	      s = 1.70158;
	    }
	    return c * (t /= d) * t * ((s + 1) * t - s) + b;
	  },
	  easeOutBack: function(t, b, _c, d, s) {
	    var c = _c - b;
	    if (s === void 0) {
	      s = 1.70158;
	    }
	    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
	  },
	  easeInOutBack: function(t, b, _c, d, s) {
	    var c = _c - b;
	    if (s === void 0) {
	      s = 1.70158;
	    }
	    if ((t /= d / 2) < 1) {
	      return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
	    } else {
	      return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
	    }
	  },
	  easeInBounce: function(t, b, _c, d) {
	    var c = _c - b;
	    var v;
	    v = tweenFunctions.easeOutBounce(d - t, 0, c, d);
	    return c - v + b;
	  },
	  easeOutBounce: function(t, b, _c, d) {
	    var c = _c - b;
	    if ((t /= d) < 1 / 2.75) {
	      return c * (7.5625 * t * t) + b;
	    } else if (t < 2 / 2.75) {
	      return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
	    } else if (t < 2.5 / 2.75) {
	      return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
	    } else {
	      return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
	    }
	  },
	  easeInOutBounce: function(t, b, _c, d) {
	    var c = _c - b;
	    var v;
	    if (t < d / 2) {
	      v = tweenFunctions.easeInBounce(t * 2, 0, c, d);
	      return v * 0.5 + b;
	    } else {
	      v = tweenFunctions.easeOutBounce(t * 2 - d, 0, c, d);
	      return v * 0.5 + c * 0.5 + b;
	    }
	  }
	};

	module.exports = tweenFunctions;


/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var filter = function filter(props, obj) {
	  var filtered = {};

	  props.forEach(function (p) {
	    var value = obj[p];

	    if (typeof value !== 'undefined') {
	      filtered[p] = value;
	    }
	  });

	  return filtered;
	};

	exports.filter = filter;

/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var match = function match(a, b, f) {
	  if (Array.isArray(a) && Array.isArray(b)) {
	    var result = [];

	    for (var i = 0, l = a.length; i < l; i++) {
	      result.push(match(a[i], b[i], f));
	    }

	    return result;
	  } else if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object' && (typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object' && a !== null && b !== null) {
	    var _result = {};

	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = Object.keys(a)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var k = _step.value;

	        _result[k] = match(a[k], b[k], f);
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }

	    return _result;
	  }

	  return f(a, b);
	};

	exports.default = match;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _points = __webpack_require__(9);

	var addCurves = function addCurves(a, b) {
	  var c = [];

	  for (var i = 0, l = a.length; i < l; i++) {
	    if (!a[i].curve && b[i].curve) {
	      c.push(_extends({}, a[i], { curve: {
	          type: 'cubic',
	          x1: a[i - 1].x,
	          y1: a[i - 1].y,
	          x2: a[i].x,
	          y2: a[i].y
	        } }));
	    } else {
	      c.push(a[i]);
	    }
	  }

	  return c;
	};

	var normaliseCurves = function normaliseCurves(a, b) {
	  return [addCurves(a, b), addCurves(b, a)];
	};

	var normalisePoints = function normalisePoints(a, b) {
	  var c = (0, _points.cubify)((0, _points.remove)(a));
	  var d = (0, _points.cubify)((0, _points.remove)(b));

	  if (d.length > c.length) {
	    c = (0, _points.add)(c, d.length);
	  } else if (c.length > d.length) {
	    d = (0, _points.add)(d, c.length);
	  }

	  return normaliseCurves(c, d);
	};

	var normalise = function normalise(a, b) {
	  var _normalisePoints = normalisePoints(a.points, b.points);

	  var _normalisePoints2 = _slicedToArray(_normalisePoints, 2);

	  var c = _normalisePoints2[0];
	  var d = _normalisePoints2[1];

	  return [_extends({}, a, { points: c }), _extends({}, b, { points: d })];
	};

	exports.default = normalise;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.scale = exports.rotate = exports.reverse = exports.remove = exports.position = exports.offset = exports.moveIndex = exports.length = exports.cubify = exports.boundingBox = exports.add = undefined;

	var _add = __webpack_require__(10);

	var _add2 = _interopRequireDefault(_add);

	var _boundingBox = __webpack_require__(14);

	var _boundingBox2 = _interopRequireDefault(_boundingBox);

	var _cubify = __webpack_require__(11);

	var _cubify2 = _interopRequireDefault(_cubify);

	var _length = __webpack_require__(16);

	var _length2 = _interopRequireDefault(_length);

	var _moveIndex = __webpack_require__(17);

	var _moveIndex2 = _interopRequireDefault(_moveIndex);

	var _offset = __webpack_require__(18);

	var _offset2 = _interopRequireDefault(_offset);

	var _position = __webpack_require__(19);

	var _position2 = _interopRequireDefault(_position);

	var _remove = __webpack_require__(20);

	var _remove2 = _interopRequireDefault(_remove);

	var _reverse = __webpack_require__(21);

	var _reverse2 = _interopRequireDefault(_reverse);

	var _rotate = __webpack_require__(22);

	var _rotate2 = _interopRequireDefault(_rotate);

	var _scale = __webpack_require__(23);

	var _scale2 = _interopRequireDefault(_scale);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.add = _add2.default;
	exports.boundingBox = _boundingBox2.default;
	exports.cubify = _cubify2.default;
	exports.length = _length2.default;
	exports.moveIndex = _moveIndex2.default;
	exports.offset = _offset2.default;
	exports.position = _position2.default;
	exports.remove = _remove2.default;
	exports.reverse = _reverse2.default;
	exports.rotate = _rotate2.default;
	exports.scale = _scale2.default;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.curvePoints = undefined;

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _cubify = __webpack_require__(11);

	var _cubify2 = _interopRequireDefault(_cubify);

	var _helpers = __webpack_require__(13);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var basicPoints = function basicPoints(a, b) {
	  return [{
	    x: (0, _helpers.numberAtInterval)(a.x, b.x, 0.5),
	    y: (0, _helpers.numberAtInterval)(a.y, b.y, 0.5)
	  }, b];
	};

	var curvePoints = function curvePoints(a, b) {
	  var _b$curve = b.curve;
	  var x1 = _b$curve.x1;
	  var y1 = _b$curve.y1;
	  var x2 = _b$curve.x2;
	  var y2 = _b$curve.y2;


	  var A = { x: a.x, y: a.y };
	  var B = { x: x1, y: y1 };
	  var C = { x: x2, y: y2 };
	  var D = { x: b.x, y: b.y };
	  var E = { x: (0, _helpers.numberAtInterval)(A.x, B.x, 0.5), y: (0, _helpers.numberAtInterval)(A.y, B.y, 0.5) };
	  var F = { x: (0, _helpers.numberAtInterval)(B.x, C.x, 0.5), y: (0, _helpers.numberAtInterval)(B.y, C.y, 0.5) };
	  var G = { x: (0, _helpers.numberAtInterval)(C.x, D.x, 0.5), y: (0, _helpers.numberAtInterval)(C.y, D.y, 0.5) };
	  var H = { x: (0, _helpers.numberAtInterval)(E.x, F.x, 0.5), y: (0, _helpers.numberAtInterval)(E.y, F.y, 0.5) };
	  var J = { x: (0, _helpers.numberAtInterval)(F.x, G.x, 0.5), y: (0, _helpers.numberAtInterval)(F.y, G.y, 0.5) };
	  var K = { x: (0, _helpers.numberAtInterval)(H.x, J.x, 0.5), y: (0, _helpers.numberAtInterval)(H.y, J.y, 0.5) };

	  return [{ x: K.x, y: K.y, curve: { type: 'cubic', x1: E.x, y1: E.y, x2: H.x, y2: H.y } }, { x: D.x, y: D.y, curve: { type: 'cubic', x1: J.x, y1: J.y, x2: G.x, y2: G.y } }];
	};

	var points = function points(a, b) {
	  return b.curve ? curvePoints(a, b) : basicPoints(a, b);
	};

	var addPoints = function addPoints(shape, pointsRequired) {
	  var s = [].concat(_toConsumableArray(shape));

	  for (var i = 1; i < s.length; i += 2) {
	    if (s.length >= pointsRequired) {
	      return s;
	    }

	    var _points = points(s[i - 1], s[i]);

	    var _points2 = _slicedToArray(_points, 2);

	    var a = _points2[0];
	    var b = _points2[1];


	    s.splice(i, 1, a, b);
	  }

	  return addPoints(s, pointsRequired);
	};

	var add = function add(shape, pointsRequired) {
	  return addPoints((0, _cubify2.default)(shape), pointsRequired);
	};

	exports.curvePoints = curvePoints;
	exports.default = add;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _arcToBezier = __webpack_require__(12);

	var _arcToBezier2 = _interopRequireDefault(_arcToBezier);

	var _helpers = __webpack_require__(13);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var cubifyShape = function cubifyShape(shape) {
	  var s = [];

	  for (var i = 0, l = shape.length; i < l; i++) {
	    var point = shape[i];

	    if (point.curve && point.curve.type !== 'cubic') {
	      var _shape = shape[i - 1];
	      var px = _shape.x;
	      var py = _shape.y;
	      var cx = point.x;
	      var cy = point.y;


	      if (point.curve.type === 'arc') {
	        var curves = (0, _arcToBezier2.default)({
	          px: px,
	          py: py,
	          cx: cx,
	          cy: cy,
	          rx: point.curve.rx,
	          ry: point.curve.ry,
	          xAxisRotation: point.curve.xAxisRotation,
	          largeArcFlag: point.curve.largeArcFlag,
	          sweepFlag: point.curve.sweepFlag
	        });

	        curves.forEach(function (_ref) {
	          var x1 = _ref.x1;
	          var y1 = _ref.y1;
	          var x2 = _ref.x2;
	          var y2 = _ref.y2;
	          var x = _ref.x;
	          var y = _ref.y;

	          s.push({ x: x, y: y, curve: { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 } });
	        });
	      } else if (point.curve.type === 'quadratic') {
	        var x1 = px + 2 / 3 * (point.curve.x1 - px);
	        var y1 = py + 2 / 3 * (point.curve.y1 - py);
	        var x2 = cx + 2 / 3 * (point.curve.x1 - cx);
	        var y2 = cy + 2 / 3 * (point.curve.y1 - cy);

	        s.push({ x: cx, y: cy, curve: { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 } });
	      }
	    } else {
	      s.push(point);
	    }
	  }

	  return s;
	};

	var cubify = function cubify(s) {
	  return (0, _helpers.applyFuncToShapes)(cubifyShape, s);
	};

	exports.default = cubify;

/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	// I extracted this from the a2c function from
	// SVG path – https://github.com/fontello/svgpath
	//
	// All credit goes to:
	//
	// Sergey Batishchev – https://github.com/snb2013
	// Vitaly Puzrin – https://github.com/puzrin
	// Alex Kocharin – https://github.com/rlidwka

	var TAU = Math.PI * 2;

	var mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
	  var x = _ref.x;
	  var y = _ref.y;

	  x *= rx;
	  y *= ry;

	  var xp = cosphi * x - sinphi * y;
	  var yp = sinphi * x + cosphi * y;

	  return {
	    x: xp + centerx,
	    y: yp + centery
	  };
	};

	var approxUnitArc = function approxUnitArc(ang1, ang2) {
	  var a = 4 / 3 * Math.tan(ang2 / 4);

	  var x1 = Math.cos(ang1);
	  var y1 = Math.sin(ang1);
	  var x2 = Math.cos(ang1 + ang2);
	  var y2 = Math.sin(ang1 + ang2);

	  return [{
	    x: x1 - y1 * a,
	    y: y1 + x1 * a
	  }, {
	    x: x2 + y2 * a,
	    y: y2 - x2 * a
	  }, {
	    x: x2,
	    y: y2
	  }];
	};

	var vectorAngle = function vectorAngle(ux, uy, vx, vy) {
	  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
	  var umag = Math.sqrt(ux * ux + uy * uy);
	  var vmag = Math.sqrt(ux * ux + uy * uy);
	  var dot = ux * vx + uy * vy;

	  var div = dot / (umag * vmag);

	  if (div > 1) {
	    div = 1;
	  }

	  if (div < -1) {
	    div = -1;
	  }

	  return sign * Math.acos(div);
	};

	var getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
	  var rxsq = Math.pow(rx, 2);
	  var rysq = Math.pow(ry, 2);
	  var pxpsq = Math.pow(pxp, 2);
	  var pypsq = Math.pow(pyp, 2);

	  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;

	  if (radicant < 0) {
	    radicant = 0;
	  }

	  radicant /= rxsq * pypsq + rysq * pxpsq;
	  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);

	  var centerxp = radicant * rx / ry * pyp;
	  var centeryp = radicant * -ry / rx * pxp;

	  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
	  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;

	  var vx1 = (pxp - centerxp) / rx;
	  var vy1 = (pyp - centeryp) / ry;
	  var vx2 = (-pxp - centerxp) / rx;
	  var vy2 = (-pyp - centeryp) / ry;

	  var ang1 = vectorAngle(1, 0, vx1, vy1);
	  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);

	  if (sweepFlag === 0 && ang2 > 0) {
	    ang2 -= TAU;
	  }

	  if (sweepFlag === 1 && ang2 < 0) {
	    ang2 += TAU;
	  }

	  return [centerx, centery, ang1, ang2];
	};

	var arcToBezier = function arcToBezier(_ref2) {
	  var px = _ref2.px;
	  var py = _ref2.py;
	  var cx = _ref2.cx;
	  var cy = _ref2.cy;
	  var rx = _ref2.rx;
	  var ry = _ref2.ry;
	  var _ref2$xAxisRotation = _ref2.xAxisRotation;
	  var xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation;
	  var _ref2$largeArcFlag = _ref2.largeArcFlag;
	  var largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag;
	  var _ref2$sweepFlag = _ref2.sweepFlag;
	  var sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;

	  var curves = [];

	  if (rx === 0 || ry === 0) {
	    return [];
	  }

	  var sinphi = Math.sin(xAxisRotation * TAU / 360);
	  var cosphi = Math.cos(xAxisRotation * TAU / 360);

	  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
	  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;

	  if (pxp === 0 && pyp === 0) {
	    return [];
	  }

	  rx = Math.abs(rx);
	  ry = Math.abs(ry);

	  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);

	  if (lambda > 1) {
	    rx *= Math.sqrt(lambda);
	    ry *= Math.sqrt(lambda);
	  }

	  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp);

	  var _getArcCenter2 = _slicedToArray(_getArcCenter, 4);

	  var centerx = _getArcCenter2[0];
	  var centery = _getArcCenter2[1];
	  var ang1 = _getArcCenter2[2];
	  var ang2 = _getArcCenter2[3];


	  var segments = Math.max(Math.ceil(Math.abs(ang2) / (TAU / 4)), 1);

	  ang2 /= segments;

	  for (var i = 0; i < segments; i++) {
	    curves.push(approxUnitArc(ang1, ang2));
	    ang1 += ang2;
	  }

	  return curves.map(function (curve) {
	    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery);

	    var x1 = _mapToEllipse.x;
	    var y1 = _mapToEllipse.y;

	    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery);

	    var x2 = _mapToEllipse2.x;
	    var y2 = _mapToEllipse2.y;

	    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery);

	    var x = _mapToEllipse3.x;
	    var y = _mapToEllipse3.y;


	    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };
	  });
	};

	exports.default = arcToBezier;

/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var angleFromSides = function angleFromSides(a, b, c) {
	  var r = Math.acos((Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) / (2 * a * b));

	  return r * (180 / Math.PI);
	};

	var applyFuncToShapes = function applyFuncToShapes(f, s) {
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }

	  if (isShapeArray(s)) {
	    return s.map(function (shape) {
	      return f.apply(undefined, [shape].concat(args));
	    });
	  }

	  return f.apply(undefined, [s].concat(args));
	};

	var getShapeArray = function getShapeArray(s) {
	  return isShapeArray(s) ? s : [s];
	};

	var isShapeArray = function isShapeArray(s) {
	  return Array.isArray(s[0]);
	};

	var numberAtInterval = function numberAtInterval(a, b, interval) {
	  var c = a === b ? 0 : Math.abs(b - a);
	  return c === 0 ? a : a < b ? a + c * interval : a - c * interval;
	};

	exports.angleFromSides = angleFromSides;
	exports.applyFuncToShapes = applyFuncToShapes;
	exports.getShapeArray = getShapeArray;
	exports.isShapeArray = isShapeArray;
	exports.numberAtInterval = numberAtInterval;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _decurve = __webpack_require__(15);

	var _decurve2 = _interopRequireDefault(_decurve);

	var _helpers = __webpack_require__(13);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var boundingBox = function boundingBox(s) {
	  var bottom = void 0;
	  var left = void 0;
	  var right = void 0;
	  var top = void 0;

	  var shapes = (0, _helpers.getShapeArray)(s);

	  shapes.map(function (shape) {
	    return (0, _decurve2.default)(shape).map(function (_ref) {
	      var x = _ref.x;
	      var y = _ref.y;

	      if (typeof bottom !== 'number' || y > bottom) {
	        bottom = y;
	      }

	      if (typeof left !== 'number' || x < left) {
	        left = x;
	      }

	      if (typeof right !== 'number' || x > right) {
	        right = x;
	      }

	      if (typeof top !== 'number' || y < top) {
	        top = y;
	      }
	    });
	  });

	  return {
	    bottom: bottom,
	    center: {
	      x: left + (right - left) / 2,
	      y: top + (bottom - top) / 2
	    },
	    left: left,
	    right: right,
	    top: top
	  };
	};

	exports.default = boundingBox;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _helpers = __webpack_require__(13);

	var _cubify = __webpack_require__(11);

	var _cubify2 = _interopRequireDefault(_cubify);

	var _add = __webpack_require__(10);

	var _length = __webpack_require__(16);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var angle = function angle(triangle) {
	  var _triangle$ = _slicedToArray(triangle[0], 2);

	  var ax = _triangle$[0];
	  var ay = _triangle$[1];

	  var _triangle$2 = _slicedToArray(triangle[1], 2);

	  var bx = _triangle$2[0];
	  var by = _triangle$2[1];

	  var _triangle$3 = _slicedToArray(triangle[2], 2);

	  var cx = _triangle$3[0];
	  var cy = _triangle$3[1];


	  var a = (0, _length.linearLength)(ax, ay, bx, by);
	  var b = (0, _length.linearLength)(bx, by, cx, cy);
	  var c = (0, _length.linearLength)(cx, cy, ax, ay);

	  return (0, _helpers.angleFromSides)(a, b, c);
	};

	var curved = function curved(shape) {
	  return shape.reduce(function (c, _ref) {
	    var curve = _ref.curve;
	    return curve ? true : c;
	  }, false);
	};

	var decurve = function decurve(shape) {
	  var accuracy = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

	  if (!curved(shape)) {
	    return shape;
	  }

	  var s = (0, _cubify2.default)(shape);
	  var d = [];

	  s.map(function (point, i) {
	    if (point.curve) {
	      var prevPoint = s[i - 1];
	      straighten(prevPoint, point, accuracy).map(function (p) {
	        return d.push(p);
	      });
	    } else {
	      d.push(point);
	    }
	  });

	  return d;
	};

	var straight = function straight(x1, y1, cx1, cy1, x2, y2, cx2, cy2, accuracy) {
	  var t1 = [[cx1, cy1], [x2, y2], [x1, y1]];
	  var t2 = [[cx2, cy2], [x1, y1], [x2, y2]];
	  return angle(t1) < accuracy && angle(t2) < accuracy;
	};

	var straighten = function straighten(prevPoint, point, accuracy) {
	  var x1 = prevPoint.x;
	  var y1 = prevPoint.y;
	  var x2 = point.x;
	  var y2 = point.y;
	  var curve = point.curve;
	  var cx1 = curve.x1;
	  var cy1 = curve.y1;
	  var cx2 = curve.x2;
	  var cy2 = curve.y2;


	  if (straight(x1, y1, cx1, cy1, x2, y2, cx2, cy2, accuracy)) {
	    return [point];
	  }

	  var _curvePoints = (0, _add.curvePoints)(prevPoint, point);

	  var _curvePoints2 = _slicedToArray(_curvePoints, 2);

	  var midPoint = _curvePoints2[0];
	  var lastPoint = _curvePoints2[1];


	  return [].concat(_toConsumableArray(straighten(prevPoint, midPoint, accuracy)), _toConsumableArray(straighten(midPoint, lastPoint, accuracy)));
	};

	exports.default = decurve;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.linearLength = undefined;

	var _decurve = __webpack_require__(15);

	var _decurve2 = _interopRequireDefault(_decurve);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var length = function length(shape, accuracy) {
	  var s = (0, _decurve2.default)(shape, accuracy);

	  return s.reduce(function (currentLength, _ref, i) {
	    var x2 = _ref.x;
	    var y2 = _ref.y;
	    var moveTo = _ref.moveTo;

	    if (!moveTo) {
	      var _s = s[i - 1];
	      var x1 = _s.x;
	      var y1 = _s.y;

	      currentLength += linearLength(x1, y1, x2, y2);
	    }

	    return currentLength;
	  }, 0);
	};

	var linearLength = function linearLength(x1, y1, x2, y2) {
	  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
	};

	exports.linearLength = linearLength;
	exports.default = length;

/***/ },
/* 17 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var moveIndex = function moveIndex(shape, offset) {
	  var k = shape.length - 1;
	  var c = shape[0];
	  var l = shape[k];
	  var o = (offset % k + k) % k;

	  if (c.x === l.x && c.y === l.y) {
	    return [{ x: shape[o].x, y: shape[o].y, moveTo: true }].concat(_toConsumableArray(shape.splice(o + 1)), _toConsumableArray(shape.splice(1, o)));
	  }

	  return shape;
	};

	exports.default = moveIndex;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _helpers = __webpack_require__(13);

	var offsetPoints = function offsetPoints(shape, x, y) {
	  return shape.map(function (point) {
	    var p = _extends({}, point);

	    p.x += x;
	    p.y += y;

	    if (p.curve) {
	      p.curve = _extends({}, p.curve);

	      if (p.curve.type === 'quadratic' || p.curve.type === 'cubic') {
	        p.curve.x1 += x;
	        p.curve.y1 += y;
	      }

	      if (p.curve.type === 'cubic') {
	        p.curve.x2 += x;
	        p.curve.y2 += y;
	      }
	    }

	    return p;
	  });
	};

	var offset = function offset(s) {
	  var x = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	  var y = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	  return (0, _helpers.applyFuncToShapes)(offsetPoints, s, x, y);
	};

	exports.default = offset;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _decurve = __webpack_require__(15);

	var _decurve2 = _interopRequireDefault(_decurve);

	var _length = __webpack_require__(16);

	var _length2 = _interopRequireDefault(_length);

	var _helpers = __webpack_require__(13);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var angle = function angle(x1, y1, x2, y2, a) {
	  if (x1 === x2) {
	    return y1 >= y2 ? 0 : 180;
	  }

	  var b = 100;
	  var c = (0, _length.linearLength)(x2, y2, x1, y1 - b);
	  var ang = (0, _helpers.angleFromSides)(a, b, c);

	  return x1 < x2 ? ang : 360 - ang;
	};

	var over = function over(shape, length, totalLength, desiredLength) {
	  var _shape = shape[length - 2];
	  var x1 = _shape.x;
	  var y1 = _shape.y;
	  var _shape2 = shape[length - 1];
	  var x2 = _shape2.x;
	  var y2 = _shape2.y;

	  var segmentLength = (0, _length.linearLength)(x1, y1, x2, y2);
	  var segmentInterval = (desiredLength - totalLength) / segmentLength + 1;
	  return { x1: x1, y1: y1, x2: x2, y2: y2, segmentInterval: segmentInterval, segmentLength: segmentLength };
	};

	var position = function position(shape, interval, accuracy) {
	  var s = (0, _decurve2.default)(shape, accuracy);
	  var l = s.length;
	  var t = (0, _length2.default)(s);
	  var d = t * interval;

	  var _ref = interval > 1 ? over(s, l, t, d) : interval < 0 ? under(s, d) : within(s, l, d);

	  var x1 = _ref.x1;
	  var y1 = _ref.y1;
	  var x2 = _ref.x2;
	  var y2 = _ref.y2;
	  var segmentInterval = _ref.segmentInterval;
	  var segmentLength = _ref.segmentLength;


	  return {
	    angle: angle(x1, y1, x2, y2, segmentLength),
	    x: (0, _helpers.numberAtInterval)(x1, x2, segmentInterval),
	    y: (0, _helpers.numberAtInterval)(y1, y2, segmentInterval)
	  };
	};

	var under = function under(shape, desiredLength) {
	  var _shape$ = shape[0];
	  var x1 = _shape$.x;
	  var y1 = _shape$.y;
	  var _shape$2 = shape[1];
	  var x2 = _shape$2.x;
	  var y2 = _shape$2.y;

	  var segmentLength = (0, _length.linearLength)(x1, y1, x2, y2);
	  var segmentInterval = desiredLength / segmentLength;
	  return { x1: x1, y1: y1, x2: x2, y2: y2, segmentInterval: segmentInterval, segmentLength: segmentLength };
	};

	var within = function within(shape, length, desiredLength) {
	  var currentLength = 0;

	  for (var i = 0; i < length; i++) {
	    var moveTo = shape[i].moveTo;


	    if (!moveTo) {
	      var _shape3 = shape[i - 1];
	      var x1 = _shape3.x;
	      var y1 = _shape3.y;
	      var _shape$i = shape[i];
	      var x2 = _shape$i.x;
	      var y2 = _shape$i.y;


	      var segmentLength = (0, _length.linearLength)(x1, y1, x2, y2);

	      if (currentLength + segmentLength >= desiredLength) {
	        var segmentInterval = (desiredLength - currentLength) / segmentLength;
	        return { x1: x1, y1: y1, x2: x2, y2: y2, segmentInterval: segmentInterval, segmentLength: segmentLength };
	      }

	      currentLength += segmentLength;
	    }
	  }
	};

	exports.default = position;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _helpers = __webpack_require__(13);

	var isBetween = function isBetween(a, b, c) {
	  if (b.curve || c.curve) {
	    return false;
	  }

	  var crossProduct = (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y);

	  if (Math.abs(crossProduct) > Number.EPSILON) {
	    return false;
	  }

	  var dotProduct = (c.x - a.x) * (b.x - a.x) + (c.y - a.y) * (b.y - a.y);

	  if (dotProduct < 0) {
	    return false;
	  }

	  var squaredLengthBA = (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);

	  if (dotProduct > squaredLengthBA) {
	    return false;
	  }

	  return true;
	};

	var removePoints = function removePoints(shape) {
	  var s = [];

	  for (var i = 0, l = shape.length; i < l; i++) {
	    var a = s[s.length - 1];
	    var b = shape[i + 1];
	    var c = shape[i];

	    if (!(a && b && c) || !isBetween(a, b, c)) {
	      s.push(c);
	    }
	  }

	  return s;
	};

	var remove = function remove(s) {
	  return (0, _helpers.applyFuncToShapes)(removePoints, s);
	};

	exports.default = remove;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _cubify = __webpack_require__(11);

	var _cubify2 = _interopRequireDefault(_cubify);

	var _helpers = __webpack_require__(13);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var reversePoints = function reversePoints(shape) {
	  var c = void 0;

	  return shape.reverse().map(function (_ref) {
	    var x = _ref.x;
	    var y = _ref.y;
	    var curve = _ref.curve;

	    var point = { x: x, y: y };

	    if (c) {
	      var _c = c;
	      var x2 = _c.x1;
	      var y2 = _c.y1;
	      var x1 = _c.x2;
	      var y1 = _c.y2;

	      point.curve = { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 };
	    }

	    c = curve ? curve : null;

	    return point;
	  });
	};

	var reverse = function reverse(s) {
	  return (0, _helpers.applyFuncToShapes)(reversePoints, (0, _cubify2.default)(s));
	};

	exports.default = reverse;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _helpers = __webpack_require__(13);

	var _boundingBox2 = __webpack_require__(14);

	var _boundingBox3 = _interopRequireDefault(_boundingBox2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var rotatePoint = function rotatePoint(x, y, c, s, about) {
	  var offsetX = about.x;
	  var offsetY = about.y;

	  var relativeX = x - offsetX;
	  var relativeY = y - offsetY;

	  return [relativeX * c - relativeY * s + offsetX, relativeX * s + relativeY * c + offsetY];
	};

	var rotatePoints = function rotatePoints(shape, angle, about) {
	  return shape.map(function (point) {
	    var r = angle * Math.PI / 180;
	    var c = Math.cos(r);
	    var s = Math.sin(r);

	    var _rotatePoint = rotatePoint(point.x, point.y, c, s, about);

	    var _rotatePoint2 = _slicedToArray(_rotatePoint, 2);

	    var x = _rotatePoint2[0];
	    var y = _rotatePoint2[1];

	    var p = _extends({}, point, { x: x, y: y });

	    if (p.curve) {
	      if (p.curve.type === 'quadratic' || p.curve.type === 'cubic') {
	        var _rotatePoint3 = rotatePoint(p.curve.x1, p.curve.y1, c, s, about);

	        var _rotatePoint4 = _slicedToArray(_rotatePoint3, 2);

	        var x1 = _rotatePoint4[0];
	        var y1 = _rotatePoint4[1];

	        p.curve = _extends({}, p.curve, { x1: x1, y1: y1 });
	      }

	      if (p.curve.type === 'cubic') {
	        var _rotatePoint5 = rotatePoint(p.curve.x2, p.curve.y2, c, s, about);

	        var _rotatePoint6 = _slicedToArray(_rotatePoint5, 2);

	        var x2 = _rotatePoint6[0];
	        var y2 = _rotatePoint6[1];

	        p.curve = _extends({}, p.curve, { x2: x2, y2: y2 });
	      }
	    }

	    return p;
	  });
	};

	var rotate = function rotate(s, angle) {
	  var _boundingBox = (0, _boundingBox3.default)(s);

	  var about = _boundingBox.center;

	  return (0, _helpers.applyFuncToShapes)(rotatePoints, s, angle, about);
	};

	exports.default = rotate;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _boundingBox2 = __webpack_require__(14);

	var _boundingBox3 = _interopRequireDefault(_boundingBox2);

	var _helpers = __webpack_require__(13);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var scalePoint = function scalePoint(point, scaleFactor, anchorX, anchorY) {
	  var p = _extends({}, point);

	  p.x = anchorX - (anchorX - p.x) * scaleFactor;
	  p.y = anchorY - (anchorY - p.y) * scaleFactor;

	  if (point.curve) {
	    p.curve = _extends({}, p.curve);

	    if (p.curve.type === 'arc') {
	      if (p.curve.rx) {
	        p.curve.rx = p.curve.rx * scaleFactor;
	      }

	      if (p.curve.ry) {
	        p.curve.ry = p.curve.ry * scaleFactor;
	      }
	    } else {
	      p.curve.x1 = anchorX - (anchorX - p.curve.x1) * scaleFactor;
	      p.curve.y1 = anchorY - (anchorY - p.curve.y1) * scaleFactor;

	      if (p.curve.type === 'cubic') {
	        p.curve.x2 = anchorX - (anchorX - p.curve.x2) * scaleFactor;
	        p.curve.y2 = anchorY - (anchorY - p.curve.y2) * scaleFactor;
	      }
	    }
	  }

	  return p;
	};

	var scale = function scale(s, scaleFactor) {
	  var anchor = arguments.length <= 2 || arguments[2] === undefined ? 'center' : arguments[2];

	  var _boundingBox = (0, _boundingBox3.default)(s);

	  var bottom = _boundingBox.bottom;
	  var center = _boundingBox.center;
	  var left = _boundingBox.left;
	  var right = _boundingBox.right;
	  var top = _boundingBox.top;


	  var anchorX = center.x;
	  var anchorY = center.y;

	  switch (anchor) {
	    case 'topLeft':
	      anchorX = left;
	      anchorY = top;
	      break;
	    case 'topRight':
	      anchorX = right;
	      anchorY = top;
	      break;
	    case 'bottomRight':
	      anchorX = right;
	      anchorY = bottom;
	      break;
	    case 'bottomLeft':
	      anchorX = left;
	      anchorY = bottom;
	      break;
	  }

	  return (0, _helpers.applyFuncToShapes)(function (shape) {
	    return shape.map(function (point) {
	      return scalePoint(point, scaleFactor, anchorX, anchorY);
	    });
	  }, s);
	};

	exports.default = scale;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _color = __webpack_require__(25);

	var _match = __webpack_require__(7);

	var _match2 = _interopRequireDefault(_match);

	var _units = __webpack_require__(26);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var middleware = [{ name: 'color', i: _color.colorIn, o: _color.colorOut }, { name: 'units', i: _units.unitsIn, o: _units.unitsOut }];

	exports.default = function (shape1, shape2, time, duration, easing) {
	  var tween = function tween(from, to) {
	    if (from === to) {
	      return from;
	    }

	    if (typeof from === 'number' && typeof to === 'number') {
	      return easing(time, from, to, duration);
	    }

	    var f = from;
	    var t = to;

	    middleware.map(function (_ref) {
	      var i = _ref.i;

	      if (typeof f === 'string' && typeof t === 'string') {
	        f = i(f);
	        t = i(t);
	      }
	    });

	    if ((typeof f === 'undefined' ? 'undefined' : _typeof(f)) === 'object' && (typeof t === 'undefined' ? 'undefined' : _typeof(t)) === 'object') {
	      for (var i in middleware) {
	        var _middleware$i = middleware[i];
	        var name = _middleware$i.name;
	        var o = _middleware$i.o;


	        if (name === f.middleware && name === t.middleware) {
	          return o((0, _match2.default)(f, t, tween));
	        }
	      }
	    }

	    return from;
	  };

	  return (0, _match2.default)(shape1, shape2, tween);
	};

/***/ },
/* 25 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var range = function range(value, min, max) {
	  return Math.max(min, Math.min(max, value));
	};

	var isHexStr = function isHexStr(v) {
	  return v.match(/^#(?:[0-9a-f]{3}){1,2}$/i) !== null;
	};
	var isRgbStr = function isRgbStr(v) {
	  return v.startsWith('rgb(');
	};
	var isRgbaStr = function isRgbaStr(v) {
	  return v.startsWith('rgba(');
	};

	var hexToObj = function hexToObj(hex) {
	  var value = hex.replace('#', '');

	  if (value.length === 3) {
	    value = value.split('').map(function (v) {
	      return '' + v + v;
	    }).join('');
	  }

	  return {
	    middleware: 'color',
	    colorType: 'hex',
	    r: parseInt(value.slice(0, 2), 16),
	    g: parseInt(value.slice(2, 4), 16),
	    b: parseInt(value.slice(4, 6), 16),
	    a: 1
	  };
	};

	var rgbToObj = function rgbToObj(v) {
	  var rgb = v.replace(/\s/g, '');

	  var _rgb$substring$split = rgb.substring(4, rgb.length - 1).split(',');

	  var _rgb$substring$split2 = _slicedToArray(_rgb$substring$split, 3);

	  var r = _rgb$substring$split2[0];
	  var g = _rgb$substring$split2[1];
	  var b = _rgb$substring$split2[2];


	  return {
	    middleware: 'color',
	    colorType: 'rgb',
	    r: parseFloat(r),
	    g: parseFloat(g),
	    b: parseFloat(b),
	    a: 1
	  };
	};

	var rgbaToObj = function rgbaToObj(v) {
	  var rgba = v.replace(/\s/g, '');

	  var _rgba$substring$split = rgba.substring(5, rgba.length - 1).split(',');

	  var _rgba$substring$split2 = _slicedToArray(_rgba$substring$split, 4);

	  var r = _rgba$substring$split2[0];
	  var g = _rgba$substring$split2[1];
	  var b = _rgba$substring$split2[2];
	  var a = _rgba$substring$split2[3];


	  return {
	    middleware: 'color',
	    colorType: 'rgba',
	    r: parseFloat(r),
	    g: parseFloat(g),
	    b: parseFloat(b),
	    a: parseFloat(a)
	  };
	};

	var objToHex = function objToHex(obj) {
	  var r = Math.ceil(range(obj.r, 0, 255)).toString(16);
	  var g = Math.ceil(range(obj.g, 0, 255)).toString(16);
	  var b = Math.ceil(range(obj.b, 0, 255)).toString(16);

	  r = r.length === 1 ? '0' + r : r;
	  g = g.length === 1 ? '0' + g : g;
	  b = b.length === 1 ? '0' + b : b;

	  return '#' + r + g + b;
	};

	var objToRgb = function objToRgb(_ref) {
	  var r = _ref.r;
	  var g = _ref.g;
	  var b = _ref.b;
	  return 'rgb(' + range(r, 0, 255) + ',' + range(g, 0, 255) + ',' + range(b, 0, 255) + ')';
	};

	var objToRgba = function objToRgba(_ref2) {
	  var r = _ref2.r;
	  var g = _ref2.g;
	  var b = _ref2.b;
	  var a = _ref2.a;
	  return 'rgba(' + range(r, 0, 255) + ',' + range(g, 0, 255) + ',' + range(b, 0, 255) + ',' + range(a, 0, 1) + ')';
	};

	var colorIn = function colorIn(v) {
	  if (isHexStr(v)) {
	    return hexToObj(v);
	  } else if (isRgbStr(v)) {
	    return rgbToObj(v);
	  } else if (isRgbaStr(v)) {
	    return rgbaToObj(v);
	  }

	  return v;
	};

	var colorOut = function colorOut(v) {
	  var colorType = v.colorType;
	  var middleware = v.middleware;


	  if (middleware === 'color') {
	    switch (colorType) {
	      case 'rgba':
	        return objToRgba(v);
	      case 'rgb':
	        return objToRgb(v);
	      case 'hex':
	        return objToHex(v);
	    }
	  }

	  return v;
	};

	exports.colorIn = colorIn;
	exports.colorOut = colorOut;

/***/ },
/* 26 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var units = ['ch', 'cm', 'em', 'ex', 'in', 'mm', 'pc', 'pt', 'px', 'rem', 'vh', 'vmax', 'vmin', 'vw', '%'];

	var unitsIn = function unitsIn(v) {
	  var parts = v.split(' ');

	  var values = parts.map(function (part) {
	    var number = parseFloat(part);
	    var unit = part.replace(number, '');

	    if (!isNaN(number) && (unit === '' || units.indexOf(unit) !== -1)) {
	      return [number, unit];
	    }

	    return part;
	  });

	  return values.toString() === parts.toString() ? v : { middleware: 'units', values: values };
	};

	var unitsOut = function unitsOut(v) {
	  var middleware = v.middleware;
	  var values = v.values;


	  if (middleware === 'units') {
	    return values.map(function (a) {
	      return a.join('');
	    }).join(' ');
	  }

	  return v;
	};

	exports.unitsIn = unitsIn;
	exports.unitsOut = unitsOut;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.tick = undefined;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _helpers = __webpack_require__(3);

	var _shape = __webpack_require__(28);

	var init = function init(playable, options) {
	  var timeline = playable.timeline;
	  var _playable$state = playable.state;
	  var state = _playable$state === undefined ? {} : _playable$state;
	  var _state$animation = state.animation;
	  var animation = _state$animation === undefined ? {} : _state$animation;
	  var durationDefault = timeline.duration;
	  var keyframes = timeline.keyframes;


	  var now = Date.now();

	  var _optionDefaults$anima = _extends({}, optionDefaults, animation, options);

	  var alternate = _optionDefaults$anima.alternate;
	  var delay = _optionDefaults$anima.delay;
	  var _optionDefaults$anima2 = _optionDefaults$anima.duration;
	  var duration = _optionDefaults$anima2 === undefined ? durationDefault : _optionDefaults$anima2;
	  var easing = _optionDefaults$anima.easing;
	  var finish = _optionDefaults$anima.finish;
	  var rate = _optionDefaults$anima.rate;
	  var start = _optionDefaults$anima.start;
	  var update = _optionDefaults$anima.update;

	  var _currentState = (0, _helpers.currentState)(animation);

	  var currentProgress = _currentState.currentProgress;
	  var currentReverse = _currentState.currentReverse;
	  var iterationsComplete = _currentState.iterationsComplete;

	  var reverse = currentReverse;
	  var reverseChanged = false;

	  if (typeof options.reverse !== 'undefined') {
	    currentReverse = options.reverse;
	    reverse = options.reverse;

	    if (animation.started) {
	      reverseChanged = options.reverse !== currentReverse;
	    }
	  }

	  var initialProgress = reverse && !reverseChanged || !reverse && reverseChanged ? 1 - currentProgress : currentProgress;

	  if (typeof options.initialProgress !== 'undefined') {
	    initialProgress = options.initialProgress;
	  }

	  var iterations = reverse ? initialProgress : 1 - initialProgress;

	  if (animation.started) {
	    iterations = animation.iterations - iterationsComplete;
	  }

	  if (typeof options.iterations !== 'undefined') {
	    iterations = options.iterations;
	  }

	  if (typeof start === 'function') {
	    start();
	  }

	  state.animation = {
	    alternate: alternate,
	    currentProgress: currentProgress,
	    currentReverse: currentReverse,
	    duration: duration / rate,
	    easing: easing,
	    finish: finish,
	    finished: false,
	    initialProgress: initialProgress,
	    iterations: iterations,
	    iterationsComplete: iterationsComplete,
	    keyframes: keyframes.map(function () {
	      return {
	        finished: false,
	        reverse: currentReverse,
	        started: false
	      };
	    }),
	    play: now + delay,
	    reverse: reverse,
	    start: start,
	    started: true,
	    update: update
	  };
	};

	var optionDefaults = {
	  alternate: false,
	  delay: 0,
	  easing: 'easeInOutQuad',
	  rate: 1
	};

	var play = function play(playable) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	  var t = arguments.length <= 2 || arguments[2] === undefined ? tick : arguments[2];

	  init(playable, options);
	  t(playable);
	};

	var tick = function tick(playable) {
	  (0, _shape.state)(playable);
	  (0, _shape.events)(playable);
	};

	exports.tick = tick;
	exports.default = play;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.state = exports.events = exports.create = undefined;

	var _create = __webpack_require__(29);

	var _create2 = _interopRequireDefault(_create);

	var _events = __webpack_require__(34);

	var _events2 = _interopRequireDefault(_events);

	var _state = __webpack_require__(35);

	var _state2 = _interopRequireDefault(_state);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.create = _create2.default;
	exports.events = _events2.default;
	exports.state = _state2.default;

	exports.default = function () {
	  for (var _len = arguments.length, shapes = Array(_len), _key = 0; _key < _len; _key++) {
	    shapes[_key] = arguments[_key];
	  }

	  var shape = (0, _create2.default)(shapes);
	  (0, _state2.default)(shape);
	  return shape;
	};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.timing = exports.manipulate = exports.keyframeShape = exports.keyframe = exports.addDurations = undefined;

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _props = __webpack_require__(30);

	var _helpers = __webpack_require__(3);

	var _points = __webpack_require__(9);

	var _svgPoints = __webpack_require__(31);

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var addDurations = function addDurations(shapes) {
	  var duration = 0;

	  shapes.forEach(function (_ref) {
	    var animation = _ref.animation;

	    if (animation) {
	      duration += animation.duration;
	    }
	  });

	  return duration;
	};

	var create = function create(shapes) {
	  var keyframes = [];
	  var motionPaths = [];

	  shapes.map(function (_ref2, i) {
	    var motionPath = _ref2.motionPath;

	    var shape = _objectWithoutProperties(_ref2, ['motionPath']);

	    var s = shape.type ? shape : shapes[i - 1];
	    keyframes.push(keyframe(s, i));
	    motionPaths.push(motionPath);
	  });

	  var duration = addDurations(keyframes);

	  return {
	    timeline: {
	      duration: duration,
	      keyframes: keyframes,
	      motionPaths: motionPaths,
	      timing: timing(keyframes, duration)
	    }
	  };
	};

	var keyframe = function keyframe(_ref3, i) {
	  var shapes = _ref3.shapes;

	  var shape = _objectWithoutProperties(_ref3, ['shapes']);

	  var s = [shape];

	  if (shapes) {
	    shapes.map(function (x) {
	      return s.push(x);
	    });
	  }

	  var k = { shapes: s.map(keyframeShape) };

	  if (i > 0) {
	    k.animation = _extends({}, _props.animationDefaults, (0, _helpers.filter)(_props.animationProps, shape));
	  }

	  return k;
	};

	var keyframeShape = function keyframeShape(shape) {
	  var k = { styles: (0, _helpers.filter)(_props.styleProps, shape) };

	  if (shape.type !== 'g') {
	    var manipulations = (0, _helpers.filter)(_props.manipulationProps, shape);
	    var points = (0, _svgPoints.toPoints)((0, _helpers.filter)(_props.shapeProps, shape));
	    k.points = manipulate(points, manipulations);
	  }

	  return k;
	};

	var manipulate = function manipulate(points, manipulations) {
	  var p = [].concat(_toConsumableArray(points));

	  Object.keys(manipulations).forEach(function (k) {
	    var args = manipulations[k];

	    switch (k) {
	      case 'moveIndex':
	        p = (0, _points.moveIndex)(p, args);
	        break;

	      case 'offset':
	        var _args = _slicedToArray(args, 2);

	        var _args$ = _args[0];
	        var x = _args$ === undefined ? 0 : _args$;
	        var _args$2 = _args[1];
	        var y = _args$2 === undefined ? 0 : _args$2;


	        p = (0, _points.offset)(p, x, y);

	        break;

	      case 'reverse':
	        if (args) {
	          p = (0, _points.reverse)(p);
	        }

	        break;

	      case 'scale':
	        var isArray = Array.isArray(args);
	        var scaleFactor = isArray ? args[0] : args;
	        var anchor = isArray ? args[1] : 'center';

	        p = (0, _points.scale)(p, scaleFactor, anchor);

	        break;
	    }
	  });

	  return p;
	};

	var timing = function timing(keyframes, duration) {
	  var currentDuration = 0;

	  return keyframes.map(function (_ref4) {
	    var animation = _ref4.animation;

	    if (animation) {
	      currentDuration += animation.duration;
	      return currentDuration / duration;
	    }

	    return currentDuration;
	  });
	};

	exports.addDurations = addDurations;
	exports.keyframe = keyframe;
	exports.keyframeShape = keyframeShape;
	exports.manipulate = manipulate;
	exports.timing = timing;
	exports.default = create;

/***/ },
/* 30 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var animationDefaults = {
	  delay: 0,
	  duration: 250
	};

	var animationProps = ['delay', 'duration', 'easing', 'finish', 'motionPath', 'name', 'start', 'update'];

	var manipulationProps = ['moveIndex', 'offset', 'reverse', 'scale'];

	var shapeProps = ['cx', 'cy', 'd', 'height', 'points', 'r', 'rx', 'ry', 'shapes', 'type', 'width', 'x', 'x1', 'x2', 'y', 'y1', 'y2'];

	var stylePropAttrMap = {
	  fill: 'fill',
	  fillOpactity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  stroke: 'stroke',
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeOpactity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  vectorEffect: 'vector-effect'
	};

	var styleProps = Object.keys(stylePropAttrMap);

	exports.animationDefaults = animationDefaults;
	exports.animationProps = animationProps;
	exports.manipulationProps = manipulationProps;
	exports.shapeProps = shapeProps;
	exports.stylePropAttrMap = stylePropAttrMap;
	exports.styleProps = styleProps;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.toPoints = exports.toPath = undefined;

	var _toPath = __webpack_require__(32);

	var _toPath2 = _interopRequireDefault(_toPath);

	var _toPoints = __webpack_require__(33);

	var _toPoints2 = _interopRequireDefault(_toPoints);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.toPath = _toPath2.default;
	exports.toPoints = _toPoints2.default;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _toPoints = __webpack_require__(33);

	var _toPoints2 = _interopRequireDefault(_toPoints);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var pointsToD = function (p) {
	  var d = '';
	  var i = 0;

	  var firstPoint = p[i];

	  for (var _iterator = p, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	    var _ref;

	    if (_isArray) {
	      if (_i >= _iterator.length) break;
	      _ref = _iterator[_i++];
	    } else {
	      _i = _iterator.next();
	      if (_i.done) break;
	      _ref = _i.value;
	    }

	    var point = _ref;

	    var isFirstPoint = i === 0;
	    var isLastPoint = i === p.length - 1;
	    var prevPoint = isFirstPoint ? null : p[i - 1];
	    var _point$curve = point.curve;
	    var curve = _point$curve === undefined ? false : _point$curve;
	    var moveTo = point.moveTo;
	    var x = point.x;
	    var y = point.y;


	    if (moveTo || isFirstPoint) {
	      if (!isLastPoint) {
	        d += 'M' + x + ',' + y;
	      }
	    } else if (curve) {
	      switch (curve.type) {
	        case 'arc':
	          var _point$curve2 = point.curve;
	          var _point$curve2$largeAr = _point$curve2.largeArcFlag;
	          var largeArcFlag = _point$curve2$largeAr === undefined ? 0 : _point$curve2$largeAr;
	          var rx = _point$curve2.rx;
	          var ry = _point$curve2.ry;
	          var _point$curve2$sweepFl = _point$curve2.sweepFlag;
	          var sweepFlag = _point$curve2$sweepFl === undefined ? 0 : _point$curve2$sweepFl;
	          var _point$curve2$xAxisRo = _point$curve2.xAxisRotation;
	          var xAxisRotation = _point$curve2$xAxisRo === undefined ? 0 : _point$curve2$xAxisRo;

	          d += 'A' + rx + ',' + ry + ',' + xAxisRotation + ',' + largeArcFlag + ',' + sweepFlag + ',' + x + ',' + y;
	          break;
	        case 'cubic':
	          var _point$curve3 = point.curve;
	          var cx1 = _point$curve3.x1;
	          var cy1 = _point$curve3.y1;
	          var cx2 = _point$curve3.x2;
	          var cy2 = _point$curve3.y2;

	          d += 'C' + cx1 + ',' + cy1 + ',' + cx2 + ',' + cy2 + ',' + x + ',' + y;
	          break;
	        case 'quadratic':
	          var _point$curve4 = point.curve;
	          var qx1 = _point$curve4.x1;
	          var qy1 = _point$curve4.y1;

	          d += 'Q' + qx1 + ',' + qy1 + ',' + x + ',' + y;
	          break;
	      }

	      if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
	        d += 'Z';
	      }
	    } else if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
	      d += 'Z';
	    } else if (x !== prevPoint.x && y !== prevPoint.y) {
	      d += 'L' + x + ',' + y;
	    } else if (x !== prevPoint.x) {
	      d += 'H' + x;
	    } else if (y !== prevPoint.y) {
	      d += 'V' + y;
	    }

	    i++;
	  }

	  return d;
	};

	var toPath = function (s) {
	  var isPoints = Array.isArray(s);
	  var isGroup = isPoints ? Array.isArray(s[0]) : s.type === 'g';
	  var points = isPoints ? s : isGroup ? s.shapes.map(function (shp) {
	    return (0, _toPoints2.default)(shp);
	  }) : (0, _toPoints2.default)(s);

	  if (isGroup) {
	    return points.map(function (p) {
	      return pointsToD(p);
	    });
	  }

	  return pointsToD(points);
	};

	exports.default = toPath;

/***/ },
/* 33 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var toPoints = function (_ref) {
	  var type = _ref.type;

	  var attributes = _objectWithoutProperties(_ref, ['type']);

	  switch (type) {
	    case 'circle':
	      return getPointsFromCircle(attributes);
	    case 'ellipse':
	      return getPointsFromEllipse(attributes);
	    case 'line':
	      return getPointsFromLine(attributes);
	    case 'path':
	      return getPointsFromPath(attributes);
	    case 'polygon':
	      return getPointsFromPolygon(attributes);
	    case 'polyline':
	      return getPointsFromPolyline(attributes);
	    case 'rect':
	      return getPointsFromRect(attributes);
	    case 'g':
	      return getPointsFromG(attributes);
	    default:
	      throw new Error('Not a valid shape type');
	  }
	};

	var getPointsFromCircle = function (_ref2) {
	  var cx = _ref2.cx;
	  var cy = _ref2.cy;
	  var r = _ref2.r;

	  return [{ x: cx, y: cy - r, moveTo: true }, { x: cx, y: cy + r, curve: { type: 'arc', rx: r, ry: r, sweepFlag: 1 } }, { x: cx, y: cy - r, curve: { type: 'arc', rx: r, ry: r, sweepFlag: 1 } }];
	};

	var getPointsFromEllipse = function (_ref3) {
	  var cx = _ref3.cx;
	  var cy = _ref3.cy;
	  var rx = _ref3.rx;
	  var ry = _ref3.ry;

	  return [{ x: cx, y: cy - ry, moveTo: true }, { x: cx, y: cy + ry, curve: { type: 'arc', rx: rx, ry: ry, sweepFlag: 1 } }, { x: cx, y: cy - ry, curve: { type: 'arc', rx: rx, ry: ry, sweepFlag: 1 } }];
	};

	var getPointsFromLine = function (_ref4) {
	  var x1 = _ref4.x1;
	  var x2 = _ref4.x2;
	  var y1 = _ref4.y1;
	  var y2 = _ref4.y2;

	  return [{ x: x1, y: y1, moveTo: true }, { x: x2, y: y2 }];
	};

	var validCommands = /[MmLlHhVvCcSsQqTtAaZz]/g;

	var commandLengths = {
	  m: 2,
	  l: 2,
	  h: 1,
	  v: 1,
	  c: 6,
	  s: 4,
	  q: 4,
	  t: 2,
	  a: 7,
	  z: 0
	};

	var optionalArcKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag'];

	var getCommands = function (d) {
	  return d.match(validCommands);
	};

	var getParams = function (d) {
	  return d.split(validCommands).map(function (v) {
	    return v.replace(/[0-9]+-/g, function (m) {
	      return m.slice(0, -1) + ' -';
	    });
	  }).map(function (v) {
	    return v.replace(/\.[0-9]+/g, function (m) {
	      return m + ' ';
	    });
	  }).map(function (v) {
	    return v.trim();
	  }).filter(function (v) {
	    return v.length > 0;
	  }).map(function (v) {
	    return v.split(/[ ,]+/).map(parseFloat).filter(function (n) {
	      return !isNaN(n);
	    });
	  });
	};

	var getPointsFromPath = function (_ref5) {
	  var d = _ref5.d;

	  var commands = getCommands(d);
	  var params = getParams(d);

	  var points = [];

	  var moveTo = void 0;

	  for (var i = 0, l = commands.length; i < l; i++) {
	    var command = commands[i];
	    var commandLength = commandLengths[command.toLowerCase()];

	    var relative = false;

	    if (commandLength > 0) {
	      var commandParams = params.shift();
	      var iterations = commandParams.length / commandLength;

	      for (var j = 0; j < iterations; j++) {
	        var prevPoint = i === 0 ? null : points[points.length - 1];

	        switch (command) {
	          case 'm':
	            relative = true;

	          case 'M':
	            var x = (relative && prevPoint ? prevPoint.x : 0) + commandParams.shift();
	            var y = (relative && prevPoint ? prevPoint.y : 0) + commandParams.shift();

	            moveTo = { x: x, y: y };

	            points.push({ x: x, y: y, moveTo: true });

	            break;

	          case 'l':
	            relative = true;

	          case 'L':
	            points.push({
	              x: (relative ? prevPoint.x : 0) + commandParams.shift(),
	              y: (relative ? prevPoint.y : 0) + commandParams.shift()
	            });

	            break;

	          case 'h':
	            relative = true;

	          case 'H':
	            points.push({
	              x: (relative ? prevPoint.x : 0) + commandParams.shift(),
	              y: prevPoint.y
	            });

	            break;

	          case 'v':
	            relative = true;

	          case 'V':
	            points.push({
	              x: prevPoint.x,
	              y: (relative ? prevPoint.y : 0) + commandParams.shift()
	            });

	            break;

	          case 'a':
	            relative = true;

	          case 'A':
	            points.push({
	              curve: {
	                type: 'arc',
	                rx: commandParams.shift(),
	                ry: commandParams.shift(),
	                xAxisRotation: commandParams.shift(),
	                largeArcFlag: commandParams.shift(),
	                sweepFlag: commandParams.shift()
	              },
	              x: (relative ? prevPoint.x : 0) + commandParams.shift(),
	              y: (relative ? prevPoint.y : 0) + commandParams.shift()
	            });

	            for (var _iterator = optionalArcKeys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	              var _ref6;

	              if (_isArray) {
	                if (_i >= _iterator.length) break;
	                _ref6 = _iterator[_i++];
	              } else {
	                _i = _iterator.next();
	                if (_i.done) break;
	                _ref6 = _i.value;
	              }

	              var k = _ref6;

	              if (points[i]['curve'][k] === 0) {
	                delete points[i]['curve'][k];
	              }
	            }

	            break;

	          case 'c':
	            relative = true;

	          case 'C':
	            points.push({
	              curve: {
	                type: 'cubic',
	                x1: (relative ? prevPoint.x : 0) + commandParams.shift(),
	                y1: (relative ? prevPoint.y : 0) + commandParams.shift(),
	                x2: (relative ? prevPoint.x : 0) + commandParams.shift(),
	                y2: (relative ? prevPoint.y : 0) + commandParams.shift()
	              },
	              x: (relative ? prevPoint.x : 0) + commandParams.shift(),
	              y: (relative ? prevPoint.y : 0) + commandParams.shift()
	            });

	            break;

	          case 's':
	            relative = true;

	          case 'S':
	            var sx2 = (relative ? prevPoint.x : 0) + commandParams.shift();
	            var sy2 = (relative ? prevPoint.y : 0) + commandParams.shift();
	            var sx = (relative ? prevPoint.x : 0) + commandParams.shift();
	            var sy = (relative ? prevPoint.y : 0) + commandParams.shift();

	            var diff = {};

	            var sx1 = void 0;
	            var sy1 = void 0;

	            if (prevPoint.curve && prevPoint.curve.type === 'cubic') {
	              diff.x = Math.abs(prevPoint.x - prevPoint.curve.x2);
	              diff.y = Math.abs(prevPoint.y - prevPoint.curve.y2);
	              sx1 = prevPoint.x < prevPoint.curve.x2 ? prevPoint.x - diff.x : prevPoint.x + diff.x;
	              sy1 = prevPoint.y < prevPoint.curve.y2 ? prevPoint.y - diff.y : prevPoint.y + diff.y;
	            } else {
	              diff.x = Math.abs(sx - sx2);
	              diff.y = Math.abs(sy - sy2);
	              sx1 = sx < sx2 ? prevPoint.x - diff.x : prevPoint.x + diff.x;
	              sy1 = sy < sy2 ? prevPoint.y + diff.y : prevPoint.y - diff.y;
	            }

	            points.push({ curve: { type: 'cubic', x1: sx1, y1: sy1, x2: sx2, y2: sy2 }, x: sx, y: sy });

	            break;

	          case 'q':
	            relative = true;

	          case 'Q':
	            points.push({
	              curve: {
	                type: 'quadratic',
	                x1: (relative ? prevPoint.x : 0) + commandParams.shift(),
	                y1: (relative ? prevPoint.y : 0) + commandParams.shift()
	              },
	              x: (relative ? prevPoint.x : 0) + commandParams.shift(),
	              y: (relative ? prevPoint.y : 0) + commandParams.shift()
	            });

	            break;

	          case 't':
	            relative = true;

	          case 'T':
	            var tx = (relative ? prevPoint.x : 0) + commandParams.shift();
	            var ty = (relative ? prevPoint.y : 0) + commandParams.shift();

	            var tx1 = void 0;
	            var ty1 = void 0;

	            if (prevPoint.curve && prevPoint.curve.type === 'quadratic') {
	              var _diff = {
	                x: Math.abs(prevPoint.x - prevPoint.curve.x1),
	                y: Math.abs(prevPoint.y - prevPoint.curve.y1)
	              };

	              tx1 = prevPoint.x < prevPoint.curve.x1 ? prevPoint.x - _diff.x : prevPoint.x + _diff.x;
	              ty1 = prevPoint.y < prevPoint.curve.y1 ? prevPoint.y - _diff.y : prevPoint.y + _diff.y;
	            } else {
	              tx1 = prevPoint.x;
	              ty1 = prevPoint.y;
	            }

	            points.push({ curve: { type: 'quadratic', x1: tx1, y1: ty1 }, x: tx, y: ty });

	            break;
	        }
	      }
	    } else {
	      points.push({ x: moveTo.x, y: moveTo.y });
	    }
	  }

	  return points;
	};

	var getPointsFromPolygon = function (_ref7) {
	  var points = _ref7.points;

	  return getPointsFromPoints({ closed: true, points: points });
	};

	var getPointsFromPolyline = function (_ref8) {
	  var points = _ref8.points;

	  return getPointsFromPoints({ closed: false, points: points });
	};

	var getPointsFromPoints = function (_ref9) {
	  var closed = _ref9.closed;
	  var points = _ref9.points;

	  var numbers = points.split(/[\s,]+/).map(function (n) {
	    return parseFloat(n);
	  });

	  var p = numbers.reduce(function (arr, point, i) {
	    if (i % 2 === 0) {
	      arr.push({ x: point });
	    } else {
	      arr[(i - 1) / 2].y = point;
	    }

	    return arr;
	  }, []);

	  if (closed) {
	    p.push(_extends({}, p[0]));
	  }

	  p[0].moveTo = true;

	  return p;
	};

	var getPointsFromRect = function (_ref10) {
	  var height = _ref10.height;
	  var rx = _ref10.rx;
	  var ry = _ref10.ry;
	  var width = _ref10.width;
	  var x = _ref10.x;
	  var y = _ref10.y;

	  if (rx || ry) {
	    return getPointsFromRectWithCornerRadius({
	      height: height,
	      rx: rx ? rx : ry,
	      ry: ry ? ry : rx,
	      width: width,
	      x: x,
	      y: y
	    });
	  }

	  return getPointsFromBasicRect({ height: height, width: width, x: x, y: y });
	};

	var getPointsFromBasicRect = function (_ref11) {
	  var height = _ref11.height;
	  var width = _ref11.width;
	  var x = _ref11.x;
	  var y = _ref11.y;

	  return [{ x: x, y: y, moveTo: true }, { x: x + width, y: y }, { x: x + width, y: y + height }, { x: x, y: y + height }, { x: x, y: y }];
	};

	var getPointsFromRectWithCornerRadius = function (_ref12) {
	  var height = _ref12.height;
	  var rx = _ref12.rx;
	  var ry = _ref12.ry;
	  var width = _ref12.width;
	  var x = _ref12.x;
	  var y = _ref12.y;

	  var curve = { type: 'arc', rx: rx, ry: ry, sweepFlag: 1 };

	  return [{ x: x + rx, y: y, moveTo: true }, { x: x + width - rx, y: y }, { x: x + width, y: y + ry, curve: curve }, { x: x + width, y: y + height - ry }, { x: x + width - rx, y: y + height, curve: curve }, { x: x + rx, y: y + height }, { x: x, y: y + height - ry, curve: curve }, { x: x, y: y + ry }, { x: x + rx, y: y, curve: curve }];
	};

	var getPointsFromG = function (_ref13) {
	  var shapes = _ref13.shapes;
	  return shapes.map(function (s) {
	    return toPoints(s);
	  });
	};

	exports.default = toPoints;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _helpers = __webpack_require__(3);

	var currentKeyframeIndex = function currentKeyframeIndex(currentProgress, keyframe2Index) {
	  if (currentProgress > 0 && currentProgress < 1) {
	    return keyframe2Index;
	  }

	  return null;
	};

	var events = function events(playable) {
	  var state = playable.state;
	  var timeline = playable.timeline;
	  var animation = state.animation;
	  var keyframes = timeline.keyframes;
	  var alternate = animation.alternate;
	  var currentProgress = animation.currentProgress;
	  var currentReverse = animation.currentReverse;
	  var iterationsComplete = animation.iterationsComplete;
	  var keyframe1Index = animation.keyframe1Index;
	  var keyframe2 = animation.keyframe2;
	  var keyframe2Index = animation.keyframe2Index;


	  if (keyframe2) {
	    var c = currentKeyframeIndex(currentProgress, keyframe2Index);

	    var p = previousKeyframeIndex({
	      alternate: alternate,
	      currentProgress: currentProgress,
	      currentReverse: currentReverse,
	      iterationsComplete: iterationsComplete,
	      keyframe1Index: keyframe1Index,
	      keyframe2Index: keyframe2Index,
	      keyframeLength: keyframes.length
	    });

	    if (p) {
	      if (p !== c || animation.keyframes[p].reverse !== currentReverse) {
	        if (animation.keyframes[p].started && !animation.keyframes[p].finished) {
	          animation.keyframes[p].started = false;
	          animation.keyframes[p].finished = true;

	          if (typeof keyframes[p].animation.finish === 'function') {
	            keyframes[p].animation.finish();
	          }
	        }
	      }
	    }

	    if (c) {
	      if (!animation.keyframes[c].started) {
	        animation.keyframes[c].started = true;
	        animation.keyframes[c].finished = false;
	        animation.keyframes[c].reverse = currentReverse;

	        if (typeof keyframes[c].animation.start === 'function') {
	          keyframes[c].animation.start();
	        }
	      }

	      if (typeof keyframes[c].animation.update === 'function') {
	        keyframes[c].animation.update();
	      }
	    }

	    if (typeof animation.update === 'function') {
	      animation.update();
	    }

	    if ((0, _helpers.finished)(animation)) {
	      animation.finished = true;

	      if (typeof animation.finish === 'function') {
	        animation.finish();
	      }
	    }
	  }
	};

	var previousKeyframeIndex = function previousKeyframeIndex(_ref) {
	  var alternate = _ref.alternate;
	  var currentProgress = _ref.currentProgress;
	  var currentReverse = _ref.currentReverse;
	  var iterationsComplete = _ref.iterationsComplete;
	  var keyframe1Index = _ref.keyframe1Index;
	  var keyframe2Index = _ref.keyframe2Index;
	  var keyframeLength = _ref.keyframeLength;

	  if (currentReverse) {
	    if (currentProgress === 0) {
	      return keyframe2Index;
	    }

	    if (keyframe2Index + 1 === keyframeLength) {
	      if (iterationsComplete > 1) {
	        if (alternate) {
	          return keyframe2Index;
	        }

	        return 1;
	      }

	      return null;
	    }

	    return keyframe2Index + 1;
	  }

	  if (currentProgress === 1) {
	    return keyframe2Index;
	  }

	  if (keyframe1Index === 0) {
	    if (iterationsComplete > 1) {
	      if (alternate) {
	        return 1;
	      }

	      return keyframeLength - 1;
	    }

	    return null;
	  }

	  return keyframe1Index;
	};

	exports.default = events;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.shapeState = exports.styleAttributes = exports.shapeAttributes = exports.normalisedShapes = exports.motionPathShapes = exports.motionPathOffset = exports.frameShapes = exports.currentShapes = exports.currentKeyframes = exports.animationState = undefined;

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _helpers = __webpack_require__(3);

	var _points = __webpack_require__(9);

	var _props = __webpack_require__(30);

	var _svgPoints = __webpack_require__(31);

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var animationState = function animationState(state, timeline) {
	  var keyframes = timeline.keyframes;
	  var timing = timeline.timing;

	  var currentAnimation = state && state.animation ? state.animation : {};
	  var animation = _extends({}, currentAnimation, (0, _helpers.currentState)(currentAnimation));
	  var currentProgress = animation.currentProgress;


	  return _extends({}, animation, currentKeyframes(currentProgress, keyframes, timing));
	};

	var currentKeyframes = function currentKeyframes(currentProgress, keyframes, timing) {
	  var keyframe1Index = timing.reduce(function (a, b, i) {
	    return currentProgress > b ? i : a;
	  }, 0);
	  var keyframe2Index = keyframe1Index + 1;
	  var keyframe1 = keyframes[keyframe1Index];
	  var keyframe2 = keyframes[keyframe2Index];

	  return { keyframe1: keyframe1, keyframe1Index: keyframe1Index, keyframe2: keyframe2, keyframe2Index: keyframe2Index };
	};

	var currentShapes = function currentShapes(_ref) {
	  var duration = _ref.duration;
	  var easing = _ref.easing;
	  var shapes1 = _ref.shapes1;
	  var shapes2 = _ref.shapes2;
	  var time = _ref.time;

	  var _normalisedShapes = normalisedShapes(shapes1, shapes2);

	  var _normalisedShapes2 = _slicedToArray(_normalisedShapes, 2);

	  var s1 = _normalisedShapes2[0];
	  var s2 = _normalisedShapes2[1];


	  return s1.map(function (a, i) {
	    var b = s2[i];
	    return (0, _helpers.tween)(a, b, time, duration, easing);
	  });
	};

	var frameShapes = function frameShapes(animation, timing) {
	  var currentProgress = animation.currentProgress;
	  var defaultEasing = animation.easing;
	  var keyframe1 = animation.keyframe1;
	  var keyframe1Index = animation.keyframe1Index;
	  var keyframe2 = animation.keyframe2;
	  var keyframe2Index = animation.keyframe2Index;
	  var shapes1 = keyframe1.shapes;

	  var _ref2 = keyframe2 || {};

	  var shapes2 = _ref2.shapes;


	  if (currentProgress === 0 || !keyframe2) {
	    return shapes1;
	  } else if (currentProgress === 1) {
	    return shapes2;
	  }

	  var scale = timing[keyframe2Index] - timing[keyframe1Index];
	  var offset = currentProgress - timing[keyframe1Index];
	  var duration = animation.duration * scale;
	  var time = duration * offset / scale;
	  var easing = (0, _helpers.easingFunc)(keyframe2.animation.easing, defaultEasing);

	  return currentShapes({
	    currentProgress: currentProgress,
	    duration: duration,
	    easing: easing,
	    shapes1: shapes1,
	    shapes2: shapes2,
	    time: time
	  });
	};

	var motionPathOffset = function motionPathOffset(animation, motionPath) {
	  var currentProgress = animation.currentProgress;
	  var defaultEasing = animation.easing;
	  var _motionPath$accuracy = motionPath.accuracy;
	  var accuracy = _motionPath$accuracy === undefined ? 1 : _motionPath$accuracy;

	  var motionPathShape = _objectWithoutProperties(motionPath, ['accuracy']);

	  var shape = (0, _svgPoints.toPoints)(motionPathShape);

	  var easing = currentProgress > 0 && currentProgress < 1 ? (0, _helpers.easingFunc)(motionPath.easing, defaultEasing) : null;

	  var interval = easing ? easing(currentProgress, 0, 1, 1) : currentProgress;

	  return (0, _points.position)(shape, interval, accuracy);
	};

	var motionPathShapes = function motionPathShapes(animation, motionPath, shapes) {
	  var _motionPath$rotate = motionPath.rotate;
	  var r = _motionPath$rotate === undefined ? false : _motionPath$rotate;

	  var _motionPathOffset = motionPathOffset(animation, motionPath);

	  var angle = _motionPathOffset.angle;
	  var x = _motionPathOffset.x;
	  var y = _motionPathOffset.y;

	  var a = typeof r === 'number' ? (r + angle) % 360 : angle;

	  if (x || y) {
	    return shapes.map(function (_ref3) {
	      var points = _ref3.points;

	      var shape = _objectWithoutProperties(_ref3, ['points']);

	      if (points) {
	        var p = (0, _points.offset)(points, x, y);

	        if (r) {
	          p = (0, _points.rotate)(p, a);
	        }

	        return _extends({}, shape, { points: p });
	      }

	      return shape;
	    });
	  }

	  return shapes;
	};

	var normalisedShapes = function normalisedShapes(shapes1, shapes2) {
	  var a = [];
	  var b = [];

	  shapes1.map(function (shape1, i) {
	    var shape2 = shapes2[i];

	    var _ref4 = shape1.points ? (0, _helpers.normalise)(shape1, shape2) : [shape1, shape2];

	    var _ref5 = _slicedToArray(_ref4, 2);

	    var s1 = _ref5[0];
	    var s2 = _ref5[1];


	    a.push(s1);
	    b.push(s2);
	  });

	  return [a, b];
	};

	var shapeAttributes = function shapeAttributes(_ref6) {
	  var points = _ref6.points;
	  var styles = _ref6.styles;

	  var attributes = styleAttributes(styles);

	  if (points) {
	    attributes.d = (0, _svgPoints.toPath)(points);
	  }

	  return attributes;
	};

	var styleAttributes = function styleAttributes(styles) {
	  var s = {};

	  Object.keys(styles).map(function (prop) {
	    var attr = _props.stylePropAttrMap[prop];

	    if (attr) {
	      s[attr] = styles[prop];
	    }
	  });

	  return s;
	};

	var shapeState = function shapeState(animation, motionPaths, timing) {
	  var keyframe2Index = animation.keyframe2Index;

	  var motionPath = motionPaths[keyframe2Index];
	  var shapes = frameShapes(animation, timing);

	  if (motionPath) {
	    return motionPathShapes(animation, motionPath, shapes).map(shapeAttributes);
	  }

	  return shapes.map(shapeAttributes);
	};

	exports.animationState = animationState;
	exports.currentKeyframes = currentKeyframes;
	exports.currentShapes = currentShapes;
	exports.frameShapes = frameShapes;
	exports.motionPathOffset = motionPathOffset;
	exports.motionPathShapes = motionPathShapes;
	exports.normalisedShapes = normalisedShapes;
	exports.shapeAttributes = shapeAttributes;
	exports.styleAttributes = styleAttributes;
	exports.shapeState = shapeState;

	exports.default = function (shape) {
	  var state = shape.state;
	  var timeline = shape.timeline;
	  var motionPaths = timeline.motionPaths;
	  var timing = timeline.timing;

	  var animation = animationState(state, timeline);
	  var shapes = shapeState(animation, motionPaths, timing);
	  var s = { animation: animation, shapes: shapes };

	  shape.state = s;

	  return s;
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.shape = exports.render = exports.play = undefined;

	var _play = __webpack_require__(37);

	var _play2 = _interopRequireDefault(_play);

	var _render = __webpack_require__(38);

	var _render2 = _interopRequireDefault(_render);

	var _shape = __webpack_require__(39);

	var _shape2 = _interopRequireDefault(_shape);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.play = _play2.default;
	exports.render = _render2.default;
	exports.shape = _shape2.default;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _helpers = __webpack_require__(3);

	var _core = __webpack_require__(1);

	var _render = __webpack_require__(38);

	var tick = function tick(playable) {
	  var animation = playable.state.animation;


	  (0, _core.tick)(playable);
	  (0, _render.renderNodes)(playable);

	  if (!(0, _helpers.paused)(animation) && !(0, _helpers.finished)(animation)) {
	    window.requestAnimationFrame(function () {
	      tick(playable);
	    });
	  }
	};

	var play = function play(playable, options) {
	  (0, _core.play)(playable, options, tick);
	};

	exports.default = play;

/***/ },
/* 38 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var addNodes = function addNodes(target, renderables) {
	  var container = svg(target);

	  renderables.map(function (_ref) {
	    var nodes = _ref.nodes;
	    var selector = _ref.selector;
	    var state = _ref.state;

	    nodes.map(function (n, i) {
	      if (i === 0 && selector) {
	        var el = container.querySelector(selector);
	        el.parentNode.replaceChild(n, el);
	      } else {
	        container.appendChild(n);
	      }

	      if (!state.shapes[i].d) {
	        container = n;
	      }
	    });
	  });
	};

	var createNodes = function createNodes(shape) {
	  shape.nodes = shape.state.shapes.map(function (_ref2) {
	    var d = _ref2.d;

	    if (d) {
	      return document.createElementNS('http://www.w3.org/2000/svg', 'path');
	    }

	    return document.createElementNS('http://www.w3.org/2000/svg', 'g');
	  });
	};

	var render = function render(target) {
	  for (var _len = arguments.length, renderables = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    renderables[_key - 1] = arguments[_key];
	  }

	  renderables.map(function (renderable) {
	    renderNodes(renderable);
	  });

	  addNodes(target, renderables);
	};

	var renderNodes = function renderNodes(renderable) {
	  if (!renderable.nodes) {
	    createNodes(renderable);
	  }

	  updateNodes(renderable);
	};

	var svgAttrs = ['height', 'preserveAspectRatio', 'viewBox', 'width'];

	var svg = function svg(target) {
	  var selector = target.selector;

	  var el = _objectWithoutProperties(target, ['selector']);

	  if (!selector) {
	    return el;
	  }

	  var outer = document.querySelector(selector);

	  if (outer.nodeName === 'svg') {
	    return outer;
	  }

	  var inner = outer.querySelector('svg');

	  if (inner.nodeName === 'svg') {
	    return inner;
	  }

	  var s = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

	  Object.keys(target).filter(function (attr) {
	    return svgAttrs.indexOf(attr) !== -1;
	  }).forEach(function (attr) {
	    s.setAttribute(attr, target[attr]);
	  });

	  outer.appendChild(s);

	  return s;
	};

	var updateNodes = function updateNodes(_ref3) {
	  var nodes = _ref3.nodes;
	  var state = _ref3.state;

	  nodes.map(function (n, i) {
	    var shape = state.shapes[i];

	    Object.keys(shape).forEach(function (key) {
	      n.setAttribute(key, shape[key]);
	    });
	  });
	};

	exports.renderNodes = renderNodes;
	exports.default = render;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.create = undefined;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _core = __webpack_require__(1);

	var _props = __webpack_require__(30);

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var attrMap = _extends({}, _props.stylePropAttrMap);
	var attrKeys = Object.keys(attrMap);
	var attrValues = attrKeys.map(function (k) {
	  return attrMap[k];
	});

	var shapeFromNode = function shapeFromNode(node) {
	  var attributes = node.attributes;
	  var type = node.nodeName;

	  var shape = { type: type };

	  Object.keys(attributes).map(function (k) {
	    var _attributes$k = attributes[k];
	    var name = _attributes$k.name;
	    var value = _attributes$k.value;


	    var i = attrValues.indexOf(name);

	    if (i > -1) {
	      name = attrKeys[i];
	    }

	    shape[name] = isNaN(value) ? value : parseFloat(value);
	  });

	  if (type === 'g') {
	    shape.shapes = [].concat(_toConsumableArray(node.children)).map(shapeFromNode);
	  }

	  return shape;
	};

	var shapeFromSelector = function shapeFromSelector(selector) {
	  if (!selector) {
	    return {};
	  }

	  var node = document.querySelector(selector);

	  return shapeFromNode(node);
	};

	var create = function create(shapes) {
	  var s = shapes.map(function (_ref) {
	    var selector = _ref.selector;

	    var props = _objectWithoutProperties(_ref, ['selector']);

	    return _extends({}, shapeFromSelector(selector), props);
	  });

	  return _extends({
	    selector: shapes[0].selector
	  }, (0, _core.create)(s));
	};

	exports.create = create;

	exports.default = function () {
	  for (var _len = arguments.length, shapes = Array(_len), _key = 0; _key < _len; _key++) {
	    shapes[_key] = arguments[_key];
	  }

	  var shape = create(shapes);
	  (0, _core.state)(shape);
	  return shape;
	};

	;

/***/ }
/******/ ])
});
;