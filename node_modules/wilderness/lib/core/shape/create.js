'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timing = exports.manipulate = exports.keyframeShape = exports.keyframe = exports.addDurations = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _props = require('./props');

var _helpers = require('../helpers');

var _points = require('points');

var _svgPoints = require('svg-points');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var addDurations = function addDurations(shapes) {
  var duration = 0;

  shapes.forEach(function (_ref) {
    var animation = _ref.animation;

    if (animation) {
      duration += animation.duration;
    }
  });

  return duration;
};

var create = function create(shapes) {
  var keyframes = [];
  var motionPaths = [];

  shapes.map(function (_ref2, i) {
    var motionPath = _ref2.motionPath;

    var shape = _objectWithoutProperties(_ref2, ['motionPath']);

    var s = shape.type ? shape : shapes[i - 1];
    keyframes.push(keyframe(s, i));
    motionPaths.push(motionPath);
  });

  var duration = addDurations(keyframes);

  return {
    timeline: {
      duration: duration,
      keyframes: keyframes,
      motionPaths: motionPaths,
      timing: timing(keyframes, duration)
    }
  };
};

var keyframe = function keyframe(_ref3, i) {
  var shapes = _ref3.shapes;

  var shape = _objectWithoutProperties(_ref3, ['shapes']);

  var s = [shape];

  if (shapes) {
    shapes.map(function (x) {
      return s.push(x);
    });
  }

  var k = { shapes: s.map(keyframeShape) };

  if (i > 0) {
    k.animation = _extends({}, _props.animationDefaults, (0, _helpers.filter)(_props.animationProps, shape));
  }

  return k;
};

var keyframeShape = function keyframeShape(shape) {
  var k = { styles: (0, _helpers.filter)(_props.styleProps, shape) };

  if (shape.type !== 'g') {
    var manipulations = (0, _helpers.filter)(_props.manipulationProps, shape);
    var points = (0, _svgPoints.toPoints)((0, _helpers.filter)(_props.shapeProps, shape));
    k.points = manipulate(points, manipulations);
  }

  return k;
};

var manipulate = function manipulate(points, manipulations) {
  var p = [].concat(_toConsumableArray(points));

  Object.keys(manipulations).forEach(function (k) {
    var args = manipulations[k];

    switch (k) {
      case 'moveIndex':
        p = (0, _points.moveIndex)(p, args);
        break;

      case 'offset':
        var _args = _slicedToArray(args, 2);

        var _args$ = _args[0];
        var x = _args$ === undefined ? 0 : _args$;
        var _args$2 = _args[1];
        var y = _args$2 === undefined ? 0 : _args$2;


        p = (0, _points.offset)(p, x, y);

        break;

      case 'reverse':
        if (args) {
          p = (0, _points.reverse)(p);
        }

        break;

      case 'scale':
        var isArray = Array.isArray(args);
        var scaleFactor = isArray ? args[0] : args;
        var anchor = isArray ? args[1] : 'center';

        p = (0, _points.scale)(p, scaleFactor, anchor);

        break;
    }
  });

  return p;
};

var timing = function timing(keyframes, duration) {
  var currentDuration = 0;

  return keyframes.map(function (_ref4) {
    var animation = _ref4.animation;

    if (animation) {
      currentDuration += animation.duration;
      return currentDuration / duration;
    }

    return currentDuration;
  });
};

exports.addDurations = addDurations;
exports.keyframe = keyframe;
exports.keyframeShape = keyframeShape;
exports.manipulate = manipulate;
exports.timing = timing;
exports.default = create;