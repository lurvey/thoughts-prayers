'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _helpers = require('../helpers');

var currentKeyframeIndex = function currentKeyframeIndex(currentProgress, keyframe2Index) {
  if (currentProgress > 0 && currentProgress < 1) {
    return keyframe2Index;
  }

  return null;
};

var events = function events(playable) {
  var state = playable.state;
  var timeline = playable.timeline;
  var animation = state.animation;
  var keyframes = timeline.keyframes;
  var alternate = animation.alternate;
  var currentProgress = animation.currentProgress;
  var currentReverse = animation.currentReverse;
  var iterationsComplete = animation.iterationsComplete;
  var keyframe1Index = animation.keyframe1Index;
  var keyframe2 = animation.keyframe2;
  var keyframe2Index = animation.keyframe2Index;


  if (keyframe2) {
    var c = currentKeyframeIndex(currentProgress, keyframe2Index);

    var p = previousKeyframeIndex({
      alternate: alternate,
      currentProgress: currentProgress,
      currentReverse: currentReverse,
      iterationsComplete: iterationsComplete,
      keyframe1Index: keyframe1Index,
      keyframe2Index: keyframe2Index,
      keyframeLength: keyframes.length
    });

    if (p) {
      if (p !== c || animation.keyframes[p].reverse !== currentReverse) {
        if (animation.keyframes[p].started && !animation.keyframes[p].finished) {
          animation.keyframes[p].started = false;
          animation.keyframes[p].finished = true;

          if (typeof keyframes[p].animation.finish === 'function') {
            keyframes[p].animation.finish();
          }
        }
      }
    }

    if (c) {
      if (!animation.keyframes[c].started) {
        animation.keyframes[c].started = true;
        animation.keyframes[c].finished = false;
        animation.keyframes[c].reverse = currentReverse;

        if (typeof keyframes[c].animation.start === 'function') {
          keyframes[c].animation.start();
        }
      }

      if (typeof keyframes[c].animation.update === 'function') {
        keyframes[c].animation.update();
      }
    }

    if (typeof animation.update === 'function') {
      animation.update();
    }

    if ((0, _helpers.finished)(animation)) {
      animation.finished = true;

      if (typeof animation.finish === 'function') {
        animation.finish();
      }
    }
  }
};

var previousKeyframeIndex = function previousKeyframeIndex(_ref) {
  var alternate = _ref.alternate;
  var currentProgress = _ref.currentProgress;
  var currentReverse = _ref.currentReverse;
  var iterationsComplete = _ref.iterationsComplete;
  var keyframe1Index = _ref.keyframe1Index;
  var keyframe2Index = _ref.keyframe2Index;
  var keyframeLength = _ref.keyframeLength;

  if (currentReverse) {
    if (currentProgress === 0) {
      return keyframe2Index;
    }

    if (keyframe2Index + 1 === keyframeLength) {
      if (iterationsComplete > 1) {
        if (alternate) {
          return keyframe2Index;
        }

        return 1;
      }

      return null;
    }

    return keyframe2Index + 1;
  }

  if (currentProgress === 1) {
    return keyframe2Index;
  }

  if (keyframe1Index === 0) {
    if (iterationsComplete > 1) {
      if (alternate) {
        return 1;
      }

      return keyframeLength - 1;
    }

    return null;
  }

  return keyframe1Index;
};

exports.default = events;