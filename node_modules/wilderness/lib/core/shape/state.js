'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shapeState = exports.styleAttributes = exports.shapeAttributes = exports.normalisedShapes = exports.motionPathShapes = exports.motionPathOffset = exports.frameShapes = exports.currentShapes = exports.currentKeyframes = exports.animationState = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _helpers = require('../helpers');

var _points = require('points');

var _props = require('./props');

var _svgPoints = require('svg-points');

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var animationState = function animationState(state, timeline) {
  var keyframes = timeline.keyframes;
  var timing = timeline.timing;

  var currentAnimation = state && state.animation ? state.animation : {};
  var animation = _extends({}, currentAnimation, (0, _helpers.currentState)(currentAnimation));
  var currentProgress = animation.currentProgress;


  return _extends({}, animation, currentKeyframes(currentProgress, keyframes, timing));
};

var currentKeyframes = function currentKeyframes(currentProgress, keyframes, timing) {
  var keyframe1Index = timing.reduce(function (a, b, i) {
    return currentProgress > b ? i : a;
  }, 0);
  var keyframe2Index = keyframe1Index + 1;
  var keyframe1 = keyframes[keyframe1Index];
  var keyframe2 = keyframes[keyframe2Index];

  return { keyframe1: keyframe1, keyframe1Index: keyframe1Index, keyframe2: keyframe2, keyframe2Index: keyframe2Index };
};

var currentShapes = function currentShapes(_ref) {
  var duration = _ref.duration;
  var easing = _ref.easing;
  var shapes1 = _ref.shapes1;
  var shapes2 = _ref.shapes2;
  var time = _ref.time;

  var _normalisedShapes = normalisedShapes(shapes1, shapes2);

  var _normalisedShapes2 = _slicedToArray(_normalisedShapes, 2);

  var s1 = _normalisedShapes2[0];
  var s2 = _normalisedShapes2[1];


  return s1.map(function (a, i) {
    var b = s2[i];
    return (0, _helpers.tween)(a, b, time, duration, easing);
  });
};

var frameShapes = function frameShapes(animation, timing) {
  var currentProgress = animation.currentProgress;
  var defaultEasing = animation.easing;
  var keyframe1 = animation.keyframe1;
  var keyframe1Index = animation.keyframe1Index;
  var keyframe2 = animation.keyframe2;
  var keyframe2Index = animation.keyframe2Index;
  var shapes1 = keyframe1.shapes;

  var _ref2 = keyframe2 || {};

  var shapes2 = _ref2.shapes;


  if (currentProgress === 0 || !keyframe2) {
    return shapes1;
  } else if (currentProgress === 1) {
    return shapes2;
  }

  var scale = timing[keyframe2Index] - timing[keyframe1Index];
  var offset = currentProgress - timing[keyframe1Index];
  var duration = animation.duration * scale;
  var time = duration * offset / scale;
  var easing = (0, _helpers.easingFunc)(keyframe2.animation.easing, defaultEasing);

  return currentShapes({
    currentProgress: currentProgress,
    duration: duration,
    easing: easing,
    shapes1: shapes1,
    shapes2: shapes2,
    time: time
  });
};

var motionPathOffset = function motionPathOffset(animation, motionPath) {
  var currentProgress = animation.currentProgress;
  var defaultEasing = animation.easing;
  var _motionPath$accuracy = motionPath.accuracy;
  var accuracy = _motionPath$accuracy === undefined ? 1 : _motionPath$accuracy;

  var motionPathShape = _objectWithoutProperties(motionPath, ['accuracy']);

  var shape = (0, _svgPoints.toPoints)(motionPathShape);

  var easing = currentProgress > 0 && currentProgress < 1 ? (0, _helpers.easingFunc)(motionPath.easing, defaultEasing) : null;

  var interval = easing ? easing(currentProgress, 0, 1, 1) : currentProgress;

  return (0, _points.position)(shape, interval, accuracy);
};

var motionPathShapes = function motionPathShapes(animation, motionPath, shapes) {
  var _motionPath$rotate = motionPath.rotate;
  var r = _motionPath$rotate === undefined ? false : _motionPath$rotate;

  var _motionPathOffset = motionPathOffset(animation, motionPath);

  var angle = _motionPathOffset.angle;
  var x = _motionPathOffset.x;
  var y = _motionPathOffset.y;

  var a = typeof r === 'number' ? (r + angle) % 360 : angle;

  if (x || y) {
    return shapes.map(function (_ref3) {
      var points = _ref3.points;

      var shape = _objectWithoutProperties(_ref3, ['points']);

      if (points) {
        var p = (0, _points.offset)(points, x, y);

        if (r) {
          p = (0, _points.rotate)(p, a);
        }

        return _extends({}, shape, { points: p });
      }

      return shape;
    });
  }

  return shapes;
};

var normalisedShapes = function normalisedShapes(shapes1, shapes2) {
  var a = [];
  var b = [];

  shapes1.map(function (shape1, i) {
    var shape2 = shapes2[i];

    var _ref4 = shape1.points ? (0, _helpers.normalise)(shape1, shape2) : [shape1, shape2];

    var _ref5 = _slicedToArray(_ref4, 2);

    var s1 = _ref5[0];
    var s2 = _ref5[1];


    a.push(s1);
    b.push(s2);
  });

  return [a, b];
};

var shapeAttributes = function shapeAttributes(_ref6) {
  var points = _ref6.points;
  var styles = _ref6.styles;

  var attributes = styleAttributes(styles);

  if (points) {
    attributes.d = (0, _svgPoints.toPath)(points);
  }

  return attributes;
};

var styleAttributes = function styleAttributes(styles) {
  var s = {};

  Object.keys(styles).map(function (prop) {
    var attr = _props.stylePropAttrMap[prop];

    if (attr) {
      s[attr] = styles[prop];
    }
  });

  return s;
};

var shapeState = function shapeState(animation, motionPaths, timing) {
  var keyframe2Index = animation.keyframe2Index;

  var motionPath = motionPaths[keyframe2Index];
  var shapes = frameShapes(animation, timing);

  if (motionPath) {
    return motionPathShapes(animation, motionPath, shapes).map(shapeAttributes);
  }

  return shapes.map(shapeAttributes);
};

exports.animationState = animationState;
exports.currentKeyframes = currentKeyframes;
exports.currentShapes = currentShapes;
exports.frameShapes = frameShapes;
exports.motionPathOffset = motionPathOffset;
exports.motionPathShapes = motionPathShapes;
exports.normalisedShapes = normalisedShapes;
exports.shapeAttributes = shapeAttributes;
exports.styleAttributes = styleAttributes;
exports.shapeState = shapeState;

exports.default = function (shape) {
  var state = shape.state;
  var timeline = shape.timeline;
  var motionPaths = timeline.motionPaths;
  var timing = timeline.timing;

  var animation = animationState(state, timeline);
  var shapes = shapeState(animation, motionPaths, timing);
  var s = { animation: animation, shapes: shapes };

  shape.state = s;

  return s;
};